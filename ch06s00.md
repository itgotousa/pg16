# 第六章 - 锁和共享内存

PostgreSQL的一个核心部件就是共享内存。共享内存可以被多个后台进程所访问。为了保证共享内存中的数据不被可能的并发执行破坏，就必须使用锁来控制这些进程的访问顺序。所以本章我们研究PostgreSQL共享内存和相关的锁的知识。

首先介绍一下基础知识，共享内存和信号量。
## 共享内存和信号量

### 共享内存

我们先演示一下两个简单的C程序
```c
```

### 信号量

这里介绍Posix信号量的知识。



## PostgreSQL中的锁

由于很多进程都可以访问同一块共享内存，且它们的访问时间是不可预知的，如果不加保护，就可能出现这种情况：进程A刚刚修往内存单元m1中存入123，再次读取m1中的内容，结果发现它变成了321。原因就是另外一个进程B也修改了内存单元m1里面的内容。在这种情况下，我们就认为内存单元m1中的内容被破坏了。为了避免这种不可预知性，我们必须使用“锁”这种机制来使得多个进程对同一个内存单元的访问过程“串行化”，即当一个进程结束对某一块内存访问之前，不允许别的进程去修改这块内存里的内容。锁这个概念对初学者非常神秘，起始它就是共享内存中的一部分。一把锁往往只有一个字节，但是它可以保护一块共享内存。

![](d0018.svg)

在上图中，我们有N把锁，可以理解为它们是共享内存中的N个字节。每一把锁都保护一块共享内存。

在PostgreSQL中有自旋锁，轻量级锁等不同类型。下面我们分别介绍。

### 自旋锁

自旋，就是自我旋转的意思。我们小时候可能都玩过陀螺。用鞭子抽打的陀螺会不停地旋转，这种状态就叫“自旋”。自旋锁和这个类似。

#### 自旋锁的原理

用下图解释

![](d0028.svg)

#### X86/X64中的TAS

X86/X64中使用XCHG指令来实现TAS。XCHG指令很简单，其示意图如下：

![](d0047.svg)

EAX是X86 CPU中的一个寄存器，locked是内存的一个地址。XCHG eax, locked这条指令的功能是把EAX寄存器中的内容和locked指向的内存单元中的内容互换。如果EAX中的内容为1, locked中的内容为0，则该条指令执行完毕后，EAX中的内容变成了0，而locked中的内容变成了1。因为一条指令具有原子性，即这条指令不会在执行中途被打断，这就实现了TAS功能。下面的代码展示了一个用X86汇编语言编写的获取和释放自旋锁的基本实现。可能读者不懂汇编，但是不要害怕，你无需过多关注指令本身的细节，可以把注意力放在每条指令后面的注释上，这样就能搞明白代码的逻辑了。

```
locked:                      /* locked是一个内存单元，里面的值开始为0，表示没有上锁 */
     dd      0               /* 如果locked里面的值为1，则表示已经上锁了 */

spin_lock:                   /* 获取自旋锁的代码的开始部分 */
     mov     eax, 1          /* 往寄存器EAX中放入1 */
     xchg    eax, [locked]   /* 这条XCHG指令是最核心的部分，它把EAX中的内容和locked内存单元中的值互换！！！*/
     test    eax, eax        /* 测试EAX寄存器中的值是否为0。EAX中的值就是先前locked中的值，而现在locked = 1 */
     jnz     spin_lock       /* 如果EAX = 1，则表明这个locked正在被别人占用; 跳转到spin_lock处，继续尝试获取 */
     
     ret                     /* 如果EAX中的值为0，则表示locked锁没有被别人占用，就是我们拿到该自旋锁了，返回！ */
                             /* 此时locked = 1，别人再用这段代码试图获取该自旋锁时，就会陷入循环中不断尝试 */

spin_unlock:                 /* 释放自旋锁的代码的开始部分 */
     xor     eax, eax        /* 把EAX寄存器清零，现在它里面的值为0 */
     xchg    eax, [locked]   /* 把EAX中的内容存入locked的内存单元中，locked = 0 */
     ret                     /* 返回。下次别人调用上面的代码试图获取该自旋锁时就可以轻松拿到了。:-) */
```

#### 自旋锁在PostgreSQL中的具体实现

下面我们研究一下PostgreSQL中对SpinLock的具体实现。
```c
/* in src/include/storage/spin.h */
/* 这些函数是外面的使用者应该使用的函数接口，硬件实现细节由它们隐藏。
 *      void SpinLockInit(volatile slock_t *lock)
 *              Initialize a spinlock (to the unlocked state).
 *
 *      void SpinLockAcquire(volatile slock_t *lock)
 *              Acquire a spinlock, waiting if necessary.
 *              Time out and abort() if unable to acquire the lock in a
 *              "reasonable" amount of time --- typically ~ 1 minute.
 *
 *      void SpinLockRelease(volatile slock_t *lock)
 *              Unlock a previously acquired lock.
 *
 *      bool SpinLockFree(slock_t *lock)
 *              Tests if the lock is free. Returns true if free, false if locked.
 *              This does *not* change the state of the lock.
 */
#define SpinLockInit(lock)      S_INIT_LOCK(lock)
#define SpinLockAcquire(lock)   S_LOCK(lock)
#define SpinLockRelease(lock)   S_UNLOCK(lock)
#define SpinLockFree(lock)      S_LOCK_FREE(lock)
```
spin.h是硬件无关的自旋锁的定义接口，它定义了操作自旋锁的函数，函数的入口参数是指向slock_t类型的指针。在X86-64平台下，slock_t实际上就是一个字节(unsigned char)。这几个函数的相关说明在上面的代码注释中已经讲得很清楚了，下面我把其中的含义翻译成中文：
- SpinLockInit(lock) - 初始化自旋锁。其实就是把lock的值变成0，表示现在没有加锁。该函数没有返回值。
- SpinLockAcquire(lock) - 获取自旋锁。这个是核心函数。当别人已经获得自旋锁lock的时候，我们调用该函数，就会等待。
- SpinLockRelease(lock) - 释放自旋锁
- SpinLockFree(lock) - 测试自旋锁lock的状态。如果lock=0则表示该锁处于未加锁状态，该函数返回true。如果lock<>0则表示该自旋锁已经被别人加锁了，该函数返回false。我们常常在试图获取某一个自旋锁之前用这个函数测试一下该自旋锁是否可能获得，避免了更多的冲突。

其中volatile关键字是告诉编译器，产生最终的机器指令的时候，volatile修饰的变量已经要放在内存里，不能被缓存在CPU的寄存器里面。

底层硬件的实现代码，支持X86-64位的代码如下：
```c
/* in src/include/storage/s_lock.h */
/*
 *	void S_INIT_LOCK(slock_t *lock)
 *		Initialize a spinlock (to the unlocked state).
 *
 *	int S_LOCK(slock_t *lock)
 *		Acquire a spinlock, waiting if necessary.
 *		Time out and abort() if unable to acquire the lock in a
 *		"reasonable" amount of time --- typically ~ 1 minute.
 *		Should return number of "delays"; see s_lock.c
 *
 *	void S_UNLOCK(slock_t *lock)
 *		Unlock a previously acquired lock.
 *
 *	bool S_LOCK_FREE(slock_t *lock)
 *		Tests if the lock is free. Returns true if free, false if locked.
 *		This does *not* change the state of the lock.
 *
 *	void SPIN_DELAY(void)
 *		Delay operation to occur inside spinlock wait loop.
 */

#define S_INIT_LOCK(lock)       S_UNLOCK(lock)
#define S_LOCK_FREE(lock)       (*(lock) == 0)

#define S_LOCK(lock) \
	(TAS(lock) ? s_lock((lock), __FILE__, __LINE__, PG_FUNCNAME_MACRO) : 0)

#define S_UNLOCK(lock)	\
	do { __asm__ __volatile__("" : : : "memory");  *(lock) = 0; } while (0)
```

```c
/* in src/include/storage/s_lock.h */
#ifdef __x86_64__               /* AMD Opteron, Intel EM64T */
#define HAS_TEST_AND_SET

typedef unsigned char slock_t;

#define TAS(lock) tas(lock)

/*
 * On Intel EM64T, it's a win to use a non-locking test before the xchg proper,
 * but only when spinning.
 *
 * See also Implementing Scalable Atomic Locks for Multi-Core Intel(tm) EM64T
 * and IA32, by Michael Chynoweth and Mary R. Lee. As of this writing, it is
 * available at:
 * http://software.intel.com/en-us/articles/implementing-scalable-atomic-locks-for-multi-core-intel-em64t-and-ia32-architectures
 */
#define TAS_SPIN(lock)    (*(lock) ? 1 : TAS(lock))

static __inline__ int tas(volatile slock_t *lock)
{
    register slock_t _res = 1; /* 告诉编译器，把_res要分配到一个寄存器中 */

    __asm__ __volatile__(
    "  lock            \n"
    "  xchgb   %0,%1   \n" /* 这条指令最关键，原子性完成了寄存器_res和内存变量lock的内容交换 */
:      "+q"(_res), "+m"(*lock)
:      /* no inputs */
:      "memory", "cc");
  
    return (int) _res; /* 返回寄存器中的值，这个值就是原来lock内存中的值 */
}

#define SPIN_DELAY() spin_delay()

static __inline__ void
spin_delay(void)
{
        /*
         * Adding a PAUSE in the spin delay loop is demonstrably a no-op on
         * Opteron, but it may be of some use on EM64T, so we keep it.
         */
        __asm__ __volatile__(
                " rep; nop                      \n");
}

#endif   /* __x86_64__ */
```

```c
/* in src/backend/storage/lmgr/s_lock.c */
int s_lock(volatile slock_t *lock, const char *file, int line, const char *func)
{
    SpinDelayStatus delayStatus;

    init_spin_delay(&delayStatus, file, line, func);

    while (TAS_SPIN(lock)) {
        perform_spin_delay(&delayStatus);
    }

    finish_spin_delay(&delayStatus);
    return delayStatus.delays;
}

```

### 轻量级锁

轻量级锁是基于Posix信号量的。

