
# 了解fork()和mmap()

为了理解PostgreSQL的共享内存结构，就必须要掌握一些基础知识。我们在本节重点介绍fork和mmap()的使用。

## 内存申请函数malloc()和释放函数free()

C语言初学者都知道动态申请内存的函数是malloc()，而释放内存的函数是free()。下面是这两个函数的基本使用：


## 第一个fork()实验

```c
      1 #include <stdio.h>
      2 #include <stdlib.h>
      3 #include <unistd.h>
      4
      5 #define MEMORY_SIZE    8192
      6
      7 char* g_ptr = NULL;
      8
      9 int main(int argc, char* argv[])
     10 {
     11 pid_t pid;
     12         printf("Hello, this is the testing for fork!\n");
     13
     14         g_ptr = (char*)malloc(MEMORY_SIZE);
     15
     16         if(NULL == g_ptr) {
     17                 printf("Sorry, I cannot allocate %d bytes, so I have to quit!\n", MEMORY_SIZE);
     18                 exit(1);
     19         }
     20
     21         g_ptr[0] = g_ptr[1] = 'A'; g_ptr[2] = 0x00;
     22
     23         pid = fork();   /* <--------- this is the key point!!!!!!! --------------- */
     24
     25         if(pid < 0) {
     26                 printf("Parent: fork is failed. I have to quit!\n");
     27                 if(NULL != g_ptr) free(g_ptr);
     28                 g_ptr = NULL;
     29                 exit(1);
     30         }
     31         else {
     32                 if(0 == pid) { /* fork succeeded, in child */
     33                         printf("Child: I will sleep for a while :-) \n");
     34                         sleep(10);
     35                         printf("Child: g_ptr is %s\n", g_ptr);
     36                         if(NULL != g_ptr) {
     37                                 printf("Child: I will free g_ptr.\n");
     38                                 free(g_ptr);
     39                                 g_ptr = NULL;
     40                         }
     41                         exit(0);
     42                 }
     43                 else { /* fork succeeded, in parent */
     44                         g_ptr[0] = g_ptr[1] = 'B'; g_ptr[2] = 0x00;
     45                         printf("Parent: g_ptr is %s\n", g_ptr);
     46                         sleep(20);
     47                 }
     48         }
     49
     50         if(NULL != g_ptr) {
     51                 printf("Parent: I will free g_ptr.\n");
     52                 free(g_ptr);
     53                 g_ptr = NULL;
     54         }
     55

```
这个例子的输出：
```
postgres@debianpg:~/code$ gcc -Wall f0.c -o f0
postgres@debianpg:~/code$ ./f0
Hello, this is the testing for fork!
Parent: g_ptr is BB
Child: I will sleep for a while :-)
Child: g_ptr is AA
Child: I will free g_ptr.
Parent: I will free g_ptr.

```

从输出：Parent: g_ptr is BB和Child: g_ptr is AA我们可以看到：父进程对自己的g_ptr内存块进行写操作(写入了两个‘B’字符)，是无法修改子进程中g_ptr指向的内存块，它里面依然是最初的值："AA"。最后也释放了两次：Child: I will free g_ptr和Parent: I will free g_ptr。我们可以推理出：全局指针变量g_ptr指向了一块大小为8192字节的内存块。在fork之后，这个内存块被复制了一份，一共两块大小都为8192字节的内存块，都是g_ptr指向。但是这两块内存分别保存在父进程和子进程当中，两者是完全独立的，谁也无法访问和修改对方的内存块。

基于以上推理，我们得出以下几条结论：

- malloc申请的内存是本地内存，只能够被本进程所读写。
- 父进程fork出子进程后，父进程里面malloc所申请的本地内存，被自动复制到了子进程里面，子进程可以继续读写这个来自父进程的内存块副本。

这个例子展示了fork和malloc之间的关系。上面的几点结论对于我们理解PostgreSQL的源码提供了基本的概念。希望大家认真搞明白这个例子里面所包含的重要基本原理。




