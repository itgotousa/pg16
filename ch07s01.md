## 内存池的操作函数

在熟悉了内存池的相关结构后，我们就要来考察内存池的相关操作函数了。PostgreSQL定义了若干函数指针，分别指向不同的操作函数，并且把这些函数打包成一个结构体，便于管理。其定义如下：
```c
/* in src/include/nodes/memnodes.h */
typedef struct MemoryContextMethods {
    void    *(*alloc) (MemoryContext context, Size size);
    void     (*free_p) (MemoryContext context, void *pointer);
    void    *(*realloc) (MemoryContext context, void *pointer, Size size);
    void     (*reset) (MemoryContext context);
    void     (*delete_context) (MemoryContext context);
    Size     (*get_chunk_space) (MemoryContext context, void *pointer);
    bool     (*is_empty) (MemoryContext context);
    void     (*stats) (MemoryContext context,
		  MemoryStatsPrintFunc printfunc, void *passthru,
		  MemoryContextCounters *totals,
		  bool print_to_stderr);
} MemoryContextMethods;
```
上述函数指针在AllocSetContext中对应的实现函数如下：
```c
/* in src/backend/utils/mmgr/aset.c */
static const MemoryContextMethods AllocSetMethods = {
    AllocSetAlloc,         /* 对应alloc */
    AllocSetFree,          /* 对应free_p */
    AllocSetRealloc,       /* 对应realloc */
    AllocSetReset,         /* 对应reset */
    AllocSetDelete,        /* 对应delete_context */
    AllocSetGetChunkSpace, /* 对应get_chunk_space */
    AllocSetIsEmpty,       /* 对应is_empty */
    AllocSetStats          /* 对应stas */ 
};
```

### 函数AllocSetContextCreate之分析

initBlockSize必须是按8字节对齐，且最小值为1024个字节。但是第一次分配的时候，通常是8K。

```c
/* in src/include/utils/memutils.h */
#define AllocSetContextCreate AllocSetContextCreateInternal
/* in src/backend/utils/mmgr/aset.c */
MemoryContext AllocSetContextCreateInternal(MemoryContext parent,
    const char *name, Size minContextSize, Size initBlockSize, Size maxBlockSize)
{
int		freeListIndex;
Size		firstBlockSize;
AllocSet	set;
AllocBlock	block;
   ......
    /* Determine size of initial block */
    firstBlockSize = MAXALIGN(sizeof(AllocSetContext)) + ALLOC_BLOCKHDRSZ + ALLOC_CHUNKHDRSZ;
    if (minContextSize != 0)
	firstBlockSize = Max(firstBlockSize, minContextSize);
    else
	firstBlockSize = Max(firstBlockSize, initBlockSize);
    /* 通常调用本函数的时候，firstBlockSize = 8192 */
    set = (AllocSet) malloc(firstBlockSize); /* 真刀真枪地分配第一个Block */
    if (set == NULL) { /* 就报错退出 */ }

    /* 首块的开始是 AllocSetContext结构，它的开始是MemoryContextData结构*/
    block = (AllocBlock) (((char *) set) + MAXALIGN(sizeof(AllocSetContext)));
    block->aset = set; /* 指向本块的头部 */
    block->freeptr = ((char *) block) + ALLOC_BLOCKHDRSZ;
    block->endptr = ((char *) set) + firstBlockSize;
    block->prev = NULL;
    block->next = NULL;

	/* Remember block as part of block list */
    set->blocks = block;
    /* keeper永远指向首块，在reset操作的时候保证本块不会被释放 */
    set->keeper = block; 

    set->initBlockSize = initBlockSize;
    set->maxBlockSize = maxBlockSize;
    set->nextBlockSize = initBlockSize;
    set->freeListIndex = freeListIndex;

    set->allocChunkLimit = ALLOC_CHUNK_LIMIT;
    /* #define ALLOC_BLOCKHDRSZ    MAXALIGN(sizeof(AllocBlockData)) */
    /* #define ALLOC_CHUNKHDRSZ	   sizeof(struct AllocChunkData) */
    while ((Size) (set->allocChunkLimit + ALLOC_CHUNKHDRSZ) >
	   (Size) ((maxBlockSize - ALLOC_BLOCKHDRSZ) / ALLOC_CHUNK_FRACTION))
	set->allocChunkLimit >>= 1;

    /* 初始化MemoryContext中的内容 */
    MemoryContextCreate((MemoryContext) set, T_AllocSetContext,
	                &AllocSetMethods, parent, name);
    /* 目前为止，只分配的第一个块，大小为firstBlockSize，记录在案 */
    ((MemoryContext) set)->mem_allocated = firstBlockSize;

    return (MemoryContext) set; /* 返回首块的头部指针 */
}
```
当上述函数执行完毕后，其内存布局如下图所示：

![](d0040.svg)

### 函数AllocSetReset分析

AllocSetReset函数重置本内存池，只保留初始Block，其余的Block全部通过free()的系统调用释放给操作系统。这是重置内存池和删除内存池操作最大的不同，其代码流程也差不多。AllocSetContext->keeper在内存池创建以后就始终指向初始Block，在内存池的整个生命周期中不会改变，所以只要判断一个block是否和keeper相等就能知道它是否是初始Block。
AllocSetReset的源码如下，和AllocSetDelete大致相同。读者参考源码中的中文注释，理解起来并不困难。
```c
/* in src/backend/utils/mmgr/aset.c */
static void AllocSetReset(MemoryContext context)
{
    AllocSet	set = (AllocSet) context;
    AllocBlock	block;
    Size	keepersize = set->keeper->endptr - ((char *) set);

    /* Clear chunk freelists */
    MemSetAligned(set->freelist, 0, sizeof(set->freelist));

    block = set->blocks;
    set->blocks = set->keeper; /* 指向初始Block */

    while (block != NULL) { /* 开始遍历Block的双向链表 */
        AllocBlock  next = block->next;

        if (block == set->keeper) { /* 这个Block是初始Block */
	    /* 重置初始Block，并不是释放它 */
	    char *datastart = ((char *) block) + ALLOC_BLOCKHDRSZ;
            wipe_mem(datastart, block->freeptr - datastart); /* 把残存的内容消除掉 */
            block->freeptr = datastart;
	    block->prev = NULL;
	    block->next = NULL;
	} else { /* 这个Block是非初始Block */
	    /* 调整内存池总体大小的值，减去即将释放的Block的大小 */
	    context->mem_allocated -= block->endptr - ((char *) block);
	    /* 把本Block残存的内容消除掉，避免安全隐患 */
 	    wipe_mem(block, block->freeptr - ((char *) block));
            free(block); /* 释放这个Block给操作系统 */
	}
	block = next;
    }
    Assert(context->mem_allocated == keepersize);
    /* 现在本内存池中只有一个初始Block，调整一下nextBlockSize */
    set->nextBlockSize = set->initBlockSize;
}
```

#### 函数AllocSetDelete分析

AllocSetDelete函数的工作是销毁内存池，它的入口参数就是一个指向该内存池初始Block头部的MemoryContext指针context。在本函数执行完毕后，context指针指向的内存池片甲不留，context指针也失效了，不能在继续引用里面的内容了。其源代码分析如下：
```c
/* in src/backend/utils/mmgr/aset.c */
static void AllocSetDelete(MemoryContext context)
{
    AllocSet  set = (AllocSet) context;
    AllocBlock block = set->blocks; /* block指向Block双向链表的头部，即活跃Block */
    Size  keepersize = set->keeper->endptr - ((char *) set); /* 计算初始Block的尺寸 */

    if (set->freeListIndex >= 0) { /* 对于即将被释放的内存池，可以把它重置后放在context_freelist数组中 */
        AllocSetFreeList *freelist = &context_freelists[set->freeListIndex];
	/* 如果本内存池没有被重置过，则首先把它重置一下，释放掉除初始Block以外的所有Block */
        if (!context->isReset)  MemoryContextResetOnly(context);
        if (freelist->num_free >= MAX_FREE_CONTEXTS)
                {
                        while (freelist->first_free != NULL)
                        {
                                AllocSetContext *oldset = freelist->first_free;

                                freelist->first_free = (AllocSetContext *) oldset->header.nextchild;
                                freelist->num_free--;

                                /* All that remains is to free the header/initial block */
                                free(oldset);
                        }
                        Assert(freelist->num_free == 0);
                }

                /* Now add the just-deleted context to the freelist. */
                set->header.nextchild = (MemoryContext) freelist->first_free;
                freelist->first_free = set;
                freelist->num_free++;

                return;
    /* 这部分代码暂时跳过 */ 
    }
    /* 开始遍历block指向的双向链表，从头到尾，依次释放该内存池中所有的Block */
    while (block != NULL) {
        AllocBlock next = block->next;
        /* 如果不是初始Block。因为set还在初始Block上呢，不能现在释放初始Block */
        if (block != set->keeper)
	    /* 调整内存池的总体积大小，减去即将释放的Block的体积 */
            context->mem_allocated -= block->endptr - ((char *) block);
            if (block != set->keeper) free(block); /* 释放所有的非初始Block */
            block = next; /* 遍历下一个Block */
    }
    /* 最后只剩下一块Block，那就是初始Block，所以内存池总大小等于初始Block的大小 */
    Assert(context->mem_allocated == keepersize);
    /* 最后释放初始Block，自然set指针也就失效了 */
    free(set);
}
```
