#### 函数AllocSetContextCreate分析

initBlockSize必须是按8字节对齐，且最小值为1024个字节。但是第一次分配的时候，通常是8K。

```c
/* in src/include/utils/memutils.h */
#define AllocSetContextCreate AllocSetContextCreateInternal
/* in src/backend/utils/mmgr/aset.c */
MemoryContext AllocSetContextCreateInternal(MemoryContext parent,
    const char *name, Size minContextSize, Size initBlockSize, Size maxBlockSize)
{
int		freeListIndex;
Size		firstBlockSize;
AllocSet	set;
AllocBlock	block;
   ......
    /* Determine size of initial block */
    firstBlockSize = MAXALIGN(sizeof(AllocSetContext)) + ALLOC_BLOCKHDRSZ + ALLOC_CHUNKHDRSZ;
    if (minContextSize != 0)
	firstBlockSize = Max(firstBlockSize, minContextSize);
    else
	firstBlockSize = Max(firstBlockSize, initBlockSize);
    /* 通常调用本函数的时候，firstBlockSize = 8192 */
    set = (AllocSet) malloc(firstBlockSize); /* 真刀真枪地分配第一个Block */
    if (set == NULL) { /* 就报错退出 */ }

    /* 首块的开始是 AllocSetContext结构，它的开始是MemoryContextData结构*/
    block = (AllocBlock) (((char *) set) + MAXALIGN(sizeof(AllocSetContext)));
    block->aset = set; /* 指向本块的头部 */
    block->freeptr = ((char *) block) + ALLOC_BLOCKHDRSZ;
    block->endptr = ((char *) set) + firstBlockSize;
    block->prev = NULL;
    block->next = NULL;

	/* Remember block as part of block list */
    set->blocks = block;
    /* keeper永远指向首块，在reset操作的时候保证本块不会被释放 */
    set->keeper = block; 

    set->initBlockSize = initBlockSize;
    set->maxBlockSize = maxBlockSize;
    set->nextBlockSize = initBlockSize;
    set->freeListIndex = freeListIndex;

    set->allocChunkLimit = ALLOC_CHUNK_LIMIT;
    /* #define ALLOC_BLOCKHDRSZ    MAXALIGN(sizeof(AllocBlockData)) */
    /* #define ALLOC_CHUNKHDRSZ	   sizeof(struct AllocChunkData) */
    while ((Size) (set->allocChunkLimit + ALLOC_CHUNKHDRSZ) >
	   (Size) ((maxBlockSize - ALLOC_BLOCKHDRSZ) / ALLOC_CHUNK_FRACTION))
	set->allocChunkLimit >>= 1;

    /* 初始化MemoryContext中的内容 */
    MemoryContextCreate((MemoryContext) set, T_AllocSetContext,
	                &AllocSetMethods, parent, name);
    /* 目前为止，只分配的第一个块，大小为firstBlockSize，记录在案 */
    ((MemoryContext) set)->mem_allocated = firstBlockSize;

    return (MemoryContext) set; /* 返回首块的头部指针 */
}
```
当上述函数执行完毕后，其内存布局如下图所示：

![](d0040.svg)

#### 函数AllocSetDelete分析

AllocSetDelete函数是销毁内存池。它的入口参数就是一个指向该内存池初始Block头部的MemoryContext指针context。在本函数执行完毕后，context指针指向的内存池片甲不留，context指针也失效了，不能在继续使用里面的内容了。
具体的源代码分析如下：
```c
static void AllocSetDelete(MemoryContext context)
{
    AllocSet  set = (AllocSet) context;
    AllocBlock block = set->blocks; /* 指向头部Block/活跃Block */
    Size  keepersize = set->keeper->endptr - ((char *) set);

    if (set->freeListIndex >= 0) { /* 这部分代码暂时跳过 */ }
    /* 开始遍历block指向的双向链表，从头到尾，依次释放该内存池中所有的Block */
    while (block != NULL) {
        AllocBlock next = block->next;
        /* 如果不是初始Block。因为set还在初始Block上呢，不能现在释放初始Block */
        if (block != set->keeper)
	    /* 调整内存池的总体积大小，减去即将释放的Block的体积 */
            context->mem_allocated -= block->endptr - ((char *) block);
            if (block != set->keeper) free(block); /* 释放所有的非初始Block */
            block = next; /* 遍历下一个Block */
    }
    /* 最后只剩下一块Block，那就是初始Block，所以内存池总大小等于初始Block的大小 */
    Assert(context->mem_allocated == keepersize);
    /* 最后释放初始Block，自然set指针也就失效了 */
    free(set);
}
```
