# 本地内存管理

本章介绍PostgreSQL本地的内存管理的深入细节知识。

注意：本章相对比较独立。建议读者在第一次阅读本书的时候，可以跳过本章。当你需要对palloc()/pfree()以及MemoryContextCreate()/MemoryContextReset()等本地内存管理函数的实现需要理解的时候，可以学习本章的内容。

### PostgreSQL内存池概述
我们可以把PostgreSQL的内存池理解为一堆内存块(Block)，这些Block是通过malloc()分配的，最终通过free()来进行释放，且它们组成一个双向链表。Block的大小有三个尺寸相关的变量规定，它们的单位均为字节(in bytes)：
- initBlockSize - 初始块的大小，通常初始块是8KB（8192个字节）。
- nextBlockSize - 下一次分配的Block的大小。
- maxBlockSize  - 最大Block的大小。

在PostgreSQL的缺省实现策略中，每当分配一个新的Block时，它的体积都比前一次分配的Block大一倍。例如：第一个初始块是8KB，则第二次分配的Block的大小是16KB，再下一次是32KB，再下一次是64KB，依次类推，直至新Block的体积等于maxBlockSize，不再增加了，以后就按照maxBlockSize大小分配新的Block。这些Block组成一个双向链表，但不是循环链表，是有头有尾的。我们称该双向链表头部的第一个Block为“头部Block”或者“活跃Block”。内存池的整体结构如下图所示：

![](d0042.svg)

最右边的Block是第一次分配的初始块(Initial Block)，最左边也是最大的Block是头部Block。初始块和其后诞生的Block有一点不同：在初始块的头部有个“控制头”，是一个C语言的结构体，它里面的成员变量用于控制整个内存池的分配销毁等行为。在PostgreSQL中这个控制头叫AllocSetContext，如上图中的右下角的大矩形。它实际上是初始块头部很小的一块区域，只是为了显示其细节，图中进行了放大。正因为初始块和其后诞生的Block有这个不同，所以产生了内存池的Delete和Reset两种操作的概念，具体含义稍后讨论。

从上图中我们可以AllocSetContext有一个指针blocks，指向内存块双向链表的头部Block。头部Block是内存池中最新诞生的Block，它永远是当前内存池中最大的Block，且只有在它里面可能存在用于未来分配的空闲空间。在它后面的Block，要么是已经没有空闲空间了，要么残存的空闲空间都被加入到了一个空闲空间列表freelist数组当中了。所以我们在内存池中寻找可用的空闲空间的时候，不需要沿着Block的双向链表进行遍历，而是直接在头部Block中寻找空闲空间，因为它后面的Block没有空闲空间了。这样就提高了搜索空闲内存的效率。

常见的内存池操作有：
- 内存池的创建(Create) ： 通过malloc()创建初始块，并初始化控制头的基本信息。
- 内存的分配(Alloc) : 向内存池申请一块内存片，结果返回指向该内存片的指针或者NULL（如果失败），类似malloc()。
- 内存的释放(Free) ：把从内存池中申请的内存片返回给内存池，供后来者使用，类似free()。
- 内存的重新分配(Realloc）：调用者嫌手里的内存片尺寸不合适，还给内存池，再从内存池里面申请一个大小合适的。
- 内存池的删除(Delete) : 彻底销毁该内存池，其中的Block一个不留。
- 内存池的重置(Reset) : 彻底销毁该内存池中除初始块除外的所有Block，再把初始块重置为该内存池刚创建(Create)时的初始状态。

### PostgreSQL内存池分析

在PostgreSQL的内存池子系统中有几个概念：MemoryContext(内存上下文)，AllocSetContext(分配集合上下文)，AllocBlock/Block(内存块)和AllocChunk/Chunk(内存片)。初学者不容易搞明白。它们的概念和之间关系，概而言之：
- 真正通过malloc()/free()分配和释放内存的单位是Block。
- Chunk是从Block里面切分的小内存片返回给调用者。
- MemoryContext和AllocSetContext是控制头，控制内存池的分配和释放。MemoryContext是一种内存池管理的抽象，AllocSetContext则是MemoryContext的一种实现方式。MemoryContext还可以有其它内存策略的分配方式，但是AllocSetContext是它的缺省实现。本书中我们只讨论AllocSetContext的实现细节。
- AllocSetContext结构的第一个成员必须是Memorycontext，两者是包含和被包含的关系。所以一个指向AllocSetContext的指针，又可以被看做是指向MemoryContext的指针。
- 一个内存池包括多个Block，每一个Block中包含一个或者多个Chunk，但是只有一个AllocSetContext(包括MemoryContext)。
- 多个PostgreSQL内存池形成树形结构，其根节点的内存池是TopMemoryContext，它在PostgreSQL实例运行的整个生命周期内都一直存在。

以上论述的具体含义，随着我们对相关数据结构和函数的源代码的分析，读者就会越来越搞明白。

#### MemoryContextData之分析

MemoryContextData是内存池的一种抽象的控制头，具体对内存池的创建、内存分配和释放、内存池的销毁等工作由具体的下一层的控制头来实现。在PostgreSQL中就是AllocSetContext。MemoryContextData的定义如下：
```c
/* in src/include/nodes/memnodes.h */
typedef struct MemoryContextData {
    NodeTag         type;                   /* identifies exact kind of context */
    bool            isReset;                /* T = no space alloced since last reset */
    bool            allowInCritSection; /* allow palloc in critical section */
    Size            mem_allocated;  /* 本内存池中所有已经分配的内存的大小, in byte */
    const MemoryContextMethods *methods;    /* 本池的相关内存分配释放的函数指针 */
    MemoryContext parent;           /* NULL if no parent (toplevel context) */
    MemoryContext firstchild;       /* head of linked list of children */
    MemoryContext prevchild;        /* previous child of same parent */
    MemoryContext nextchild;        /* next child of same parent */
    const char *name;                       /* context name (just for debugging) */
    const char *ident;                      /* context ID if any (just for debugging) */
    MemoryContextCallback *reset_cbs;       /* list of reset/delete callbacks */
} MemoryContextData;
/* in src/include/utils/palloc.h */
typedef struct MemoryContextData *MemoryContext;
```
MemoryContextData的重要成员变量的含义如下：
- type - 内存池的类型，目前没有太大的意义。
- isReset - 该内存池是否被重置过。内存池被重置后焕然一新，其里面没有任何Chunk被分配出去，isReset为true。一旦有Chunk被分配出去，isRest就为false。
- mem_allocated - 本内存池所有已经通过malloc()分配的Block的大小之和，即本内存池的总体积。
- methods - 内存池创建销毁等操作的函数指针
- name - 用于调试内存池使用，平时用不到。它必须是一个常量字符串，如"MyPool"，不能是一个字符串变量。
- ident - 也是用于调试的时候使用，这里可以忽略。

我们观察到MemoryContextData有几个指针，parent/firstchild/prevchild/nextchild，通过它们，多个内存池可以形成了一个树形结构，如下图所示：

![](d0024.svg)

我窃以为：prevchild和nextchild变量的名字起的不好。它们实际上指向了自己的兄弟，所以应该叫做pre_sibling和next_sibling。

在PostgreSQL中只有一个TopMemoryContext，它是处于根节点位置的内存池。在它下面还有若干内存池。它们使用如下的全局变量来进行记录：
```c
/* in src/backend/utils/mmgr/mcxt.c */
MemoryContext TopMemoryContext = NULL;      /* 根内存池的指针 */
MemoryContext CurrentMemoryContext = NULL; /* 当前内存池的指针 */

MemoryContext ErrorContext = NULL;
MemoryContext PostmasterContext = NULL;
MemoryContext CacheMemoryContext = NULL;
MemoryContext MessageContext = NULL;
MemoryContext TopTransactionContext = NULL;
MemoryContext CurTransactionContext = NULL;
```
这些内存池形成如下的树形结构，其中每一个矩形都表示一个内存池。

![](d0026.svg)

#### 数据结构AllocSetContext分析

AllocSetContext是MemoryContext的具体实现，也是MemoryContext在PostgreSQL中的缺省实现方式。它的定义如下：
```c
/* in src/backend/utils/mmgr/aset.c */
typedef struct AllocSetContext {
    MemoryContextData header;	/* 第一个成员必须是MemoryContextData */
    /* Info about storage allocated in this context: */
    AllocBlock	blocks;	       /* 指向本内存池的头部Block */
    AllocChunk  freelist[ALLOCSET_NUM_FREELISTS];  /* free chunk lists */
/* Allocation parameters for this context: */
    Size    initBlockSize;	/* initial block size */
    Size    maxBlockSize;	/* maximum block size */
    Size    nextBlockSize;	/* next block size to allocate */
    Size    allocChunkLimit;	/* effective chunk size limit */
    AllocBlock	keeper;			/* keep this block over resets */
/* freelist this context could be put in, or -1 if not a candidate: */
    int			freeListIndex;	/* index in context_freelists[], or -1 */
} AllocSetContext;

typedef AllocSetContext *AllocSet;
```
AllocSetContext的个成员变量的含义如下：
- header - MemoryContextData结构。其它方式的MemoryContextData的具体实现也必须把它设置为第一个成员。
- blocks - 指向本内存池内所有Block形成的双向链表的头部。
- freelist是一个数组，共计11个元素，它们指向空闲内存片AllocChunk的单向链表。具体含义后面会详细讨论。
- initBlockSize/maxBlockSizenextBlockSize - 三个控制Block体积的尺寸变量
- keeper - 指向初始块。在内存池重置操作的时候通过它来判断哪一个Block是初始块。
- freeListIndex - 后面有一小节来讨论它的作用。

#### 数据结构AllocBlockData分析

AllocBlockData表示一个Block。每当内存池中分配一个新的Block的时候，它的头部就是AllocBlockData结构体。注意，初始块不同，它的头部是AllocSetContext和AllocBlockData。AllocBlockData的数据结构定义如下：
```c
/* in src/backend/utils/mmgr/aset.c */
typedef struct AllocBlockData {
    AllocSet    aset;	    /* 指向本内存池的初始块头部的AllocSetContext */
    AllocBlock	prev;	    /* Block双向链表的向前指针 */
    AllocBlock	next;	    /* Block双向链表的向后指针 */
    char       *freeptr;    /* 本块空闲内存的起始地址 */
    char       *endptr;	    /* 本块的结束地址 */
}  AllocBlockData;
typedef struct AllocBlockData *AllocBlock;
```
AllocBlockData的各成员变量的含义比较简单，请参考上面的注释。freeptr和endptr表示本块空闲内存的首尾指针，则本块空闲内存的大小为endptr - freeptr。

#### 数据结构AllocChunkData分析

AllocChunkData表示一个Chunk，翻译成中文可以称为“内存片”。每次调用palloc()从内存池中分配的内存都是一个Chunk，其释放是通过pfree()来完整的。它的数据结构非常简单：
```c
/* in src/backend/utils/mmgr/aset.c */
typedef struct AllocChunkData {
    Size    size;   /* 8 bytes in X64 */
    /* aset is the owning aset if allocated, or the freelist link if free */
    void    *aset;  /* 8 bytes in X64 */
    /* there must not be any padding to reach a MAXALIGN boundary here! */
} AllocChunkData;

typedef struct AllocChunkData *AllocChunk;
```
我们可以用下图来表示它的内存结构：

![](d0039.svg)

一个Chunk可以分配头部和真正的数据区。头部分为本Chunk的大小和一个指针aset，共计16个字节。Chunk的要点如下：
- size指的是真正数据的大小，不包括头部的16个字节。
- aset指针是“一鱼两吃”：当本Chunk已经被分配使用，aset指向初始块头部的AllocSetContext。当本Chunk被pfree()释放会内存池中的时候，aset被用作在freelist中形成的单向链表中指向下一个成员的指针。这是程序设计上的一个小技巧，同一个指针在不同的情况下作为不同的用途。其具体含义我们在讨论freelist的时候再展开。
- palloc()申请的Chunk最终返回给调用者的指针是图中的p指针，不是Chunk的开头。
- aset指针和真正的数据之间是紧挨着的，不能有空隙。

为什么aset指针必须要和真正的数据紧挨着呢？这是因为我们往往需要根据p指针找到对应的Chunk头部，进而可以获得size和aset的信息。有时候也要根据Chunk指针获得指向真正数据的指针。在Chunk头部和指向数据的指针p之间没有空隙的话，只要把指针前后移动固定的位置就可以达到这个目的。请参考下面的相关操作的定义：
```c
/* in src/backend/utils/mmgr/aset.c */
#define ALLOC_CHUNKHDRSZ	     sizeof(struct AllocChunkData)
#define AllocPointerGetChunk(ptr)    ((AllocChunk)(((char *)(ptr)) - ALLOC_CHUNKHDRSZ))
#define AllocChunkGetPointer(chk)    ((AllocPointer)(((char *)(chk)) + ALLOC_CHUNKHDRSZ))

/* in src/backend/utils/mmgr/mcxt.c */
void pfree(void *pointer)
{
        MemoryContext context = GetMemoryChunkContext(pointer);
        context->methods->free_p(context, pointer);
}

/* in src/include/utils/memutils.h */
static inline MemoryContext GetMemoryChunkContext(void *pointer)
{
        MemoryContext context;
	/* 往前移动一个指针就可以拿到aset指针，指向MemoryContext */
        context = *(MemoryContext *) (((char *) pointer) - sizeof(void *)); 
        return context;
}
```
AllocPointerGetChunk是根据指向真正数据的指针ptr来获得指向AllocChunk的指针chk，其操作就是把ptr指针减16个字节就获得了，因为AllocChunkData结构的大小是16个字节(sizeof(struct AllocChunkData))。
```c
chk = ptr - sizeof(struct AllocChunkData) /* chk = ptr - 16 */
```
同样的道理，AllocChunkGetPointer是根据指向AllocChunk的指针chk获得指向真正数据的指针ptr。
```c
ptr = chk + sizeof(struct AllocChunkData) /* ptr = ptr + 16 */
```
 理解了这些，大家对pfree()函数中的GetMemoryChunkContext就不难理解。

#### 空闲内存片freelist分析

![](d0023.svg)



当完成初始化后，它的内存分配如图所示.


当完成初始化后，它的内存分配如图所示.


当完成初始化后，它的内存分配如图所示.

#### 函数AllocSetContextCreate分析

initBlockSize必须是按8字节对齐，且最小值为1024个字节。但是第一次分配的时候，通常是8K。

```c
/* in src/include/utils/memutils.h */
#define AllocSetContextCreate AllocSetContextCreateInternal
/* in src/backend/utils/mmgr/aset.c */
MemoryContext AllocSetContextCreateInternal(MemoryContext parent,
    const char *name, Size minContextSize, Size initBlockSize, Size maxBlockSize)
{
int		freeListIndex;
Size		firstBlockSize;
AllocSet	set;
AllocBlock	block;
   ......
    /* Determine size of initial block */
    firstBlockSize = MAXALIGN(sizeof(AllocSetContext)) + ALLOC_BLOCKHDRSZ + ALLOC_CHUNKHDRSZ;
    if (minContextSize != 0)
	firstBlockSize = Max(firstBlockSize, minContextSize);
    else
	firstBlockSize = Max(firstBlockSize, initBlockSize);
    /* 通常调用本函数的时候，firstBlockSize = 8192 */
    set = (AllocSet) malloc(firstBlockSize); /* 真刀真枪地分配第一个Block */
    if (set == NULL) { /* 就报错退出 */ }

    /* 首块的开始是 AllocSetContext结构，它的开始是MemoryContextData结构*/
    block = (AllocBlock) (((char *) set) + MAXALIGN(sizeof(AllocSetContext)));
    block->aset = set; /* 指向本块的头部 */
    block->freeptr = ((char *) block) + ALLOC_BLOCKHDRSZ;
    block->endptr = ((char *) set) + firstBlockSize;
    block->prev = NULL;
    block->next = NULL;

	/* Remember block as part of block list */
    set->blocks = block;
    /* keeper永远指向首块，在reset操作的时候保证本块不会被释放 */
    set->keeper = block; 

    set->initBlockSize = initBlockSize;
    set->maxBlockSize = maxBlockSize;
    set->nextBlockSize = initBlockSize;
    set->freeListIndex = freeListIndex;

    set->allocChunkLimit = ALLOC_CHUNK_LIMIT;
    /* #define ALLOC_BLOCKHDRSZ    MAXALIGN(sizeof(AllocBlockData)) */
    /* #define ALLOC_CHUNKHDRSZ	   sizeof(struct AllocChunkData) */
    while ((Size) (set->allocChunkLimit + ALLOC_CHUNKHDRSZ) >
	   (Size) ((maxBlockSize - ALLOC_BLOCKHDRSZ) / ALLOC_CHUNK_FRACTION))
	set->allocChunkLimit >>= 1;

    /* 初始化MemoryContext中的内容 */
    MemoryContextCreate((MemoryContext) set, T_AllocSetContext,
	                &AllocSetMethods, parent, name);
    /* 目前为止，只分配的第一个块，大小为firstBlockSize，记录在案 */
    ((MemoryContext) set)->mem_allocated = firstBlockSize;

    return (MemoryContext) set; /* 返回首块的头部指针 */
}
```
当上述函数执行完毕后，其内存布局如下图所示：

![](d0040.svg)


