# 内存池管理子系统

PostgreSQL内核是采用C语言编写的，且只支持C99标准，目的就是能够让PostgreSQL运行在更加广泛的硬件平台和操作系统之上。C语言作为排名第一的系统软件开发语言，它给了程序员最大的内存管理的自由度，也带来了很多潜在的问题。为了避免C语言编写的软件出现内存泄漏，高质量的软件往往采用内存池的技术，PostgreSQL也不例外。本章会带领读者剖析PostgreSQL内存池子系统的设计思想和具体实现细节。

注意：本章相对比较独立。建议读者在第一次阅读本书时，可跳过本章。当你需要对PostgreSQL源代码普遍存在的palloc()/pfree()等本地内存管理函数的实现有更深入理解的时候，可再回过头来阅读本章的内容。

C语言初学者都知道，在C程序中申请和释放内存使用的是malloc()/free()等函数。内存池技术的思想非常简单，通俗地说就是“一次批发，多次零售”。malloc()和free()是系统调用，其开销相对较大，同时malloc(1)和malloc(8192)的开销差别不大，所以一个很自然的想法就是尽量减少对malloc()和free()的调用次数。内存池技术会一次性使用malloc()分配大块内存，类似批发；然后未来的小额内存申请会从这个大块内存中不断切出来尺寸合适的内存片，类似零售。而这种切蛋糕的操作只是简单的内存指针的位置移动，不再涉及系统调用，所以非常高效。当这块大内存上所有的内存都不再使用后，再一次性通过free()再把这块内存释放掉。这个思想是非常容易理解的。

## 内存池子系统概述

PostgreSQL的内存池管理子系统，提供了palloc()和pfree()的内存分配和释放接口函数，非常类似malloc()和free()。我们可以把PostgreSQL的内存池理解为一堆内存块(Block)的集合。这些Block是通过malloc()分配的，最终通过free()来进行释放，且它们组成一个双向链表。PostgreSQL的内存池概念可以用下图表示：

![](d0042.svg)

在上图中，最右边的Block是内存池刚刚创建时用malloc()分配的初始Block(Initial Block)。它的大小由一个整型变量initBlockSize控制，一般为8192，所以初始Block的大小通常为8K。内存池使用三个变量来控制每次分配的Block的大小，它们的单位均为字节(in bytes)：
- initBlockSize - 初始Block的大小。
- nextBlockSize - 下一次分配的Block的大小。
- maxBlockSize  - 最大Block的大小。

在PostgreSQL的缺省实现策略中，采用贪吃型的内存分配方案：每当通过malloc()分配一个新的Block时，它的体积都比前一次分配的Block大一倍。例如：第一个初始Block的大小是8KB，则第二次分配的Block的大小是16KB，再下一次是32KB，再下一次是64KB，依次类推，直至新Block的体积等于maxBlockSize，就不再增加了，以后就按照maxBlockSize大小分配新的Block。这些Block组成一个双向链表，有头有尾。每次malloc()分配一个更大的Block之后，内存池都会把这个新鲜出炉的Block放在Block双向链表的头部。我们把这个Block叫做“Active Block”，即活跃Block。

当申请者使用palloc()函数向内存池申请内存时，内存池返回给申请者的内存叫内存片(Chunk)，Chunk是从某一个Block中切下来的一小块。内存池为Chunk寻找空闲内存时，只在活跃Block中的空闲内存区中寻找。只有当活跃Block中的空闲内存不够时，才会再次malloc()出一个更大的新块作为新的活跃Block。所以活跃Block后面的老Block必定基本上没有什么空闲内存了。内存池只在活跃Block里面寻找空闲内存，不用遍历双向链表，这就是“活跃”的含义。上图中最左边的Block便是活跃Block。Block组成的双链只是用于内存池销毁或者重置的时候进行遍历使用。

初始Block和其后诞生的Block（包括活跃Block）有一点不同：在初始Block的头部有个“控制头”AllocSetContext，这是一个C语言的结构体，其中的成员变量用于控制整个内存池的分配销毁等行为。上图中的右下角的大矩形就是AllocSetContext。请注意：它实际上是初始Block头部很小的一块区域，只是为了显示其细节，图中进行了放大。正因为初始Block和其后诞生的Block的头部有这个区别，所以产生了内存池的删除(Delete)和重置(Reset)两种操作的概念，具体含义稍后讨论。AllocSetContext中有一个指针blocks，始终指向内存池中Block双向链表的活跃Block。

内存池(Pool)，内存块(Block)和内存片(Chunk)是内存池系统中的三个基本概念。它们的关系总结如下：
- Pool包含一个或者多个Block。在内存池被创建后，只有一个初始Block。随着申请者越来越多时，Pool再分配出更多的Block。
- Block是malloc()和free()的基本单位，任何一个Block只属于一个Pool。一个Block包含一个或者多个Chunk。
- Chunk返回给申请者的内存，它是Block中的一部分，所以任何一个Chunk只属于一个Block。

对内存池的引用可以使用一个指针，指向它的初始Block的头部，即AllocSetContext。对内存池的操作如下所示，每一个操作对应一个函数：
- 内存池的创建(Create) ：通过malloc()创建初始Block，并初始化控制头的基本信息。
- 内存片的分配(Alloc) : 从内存池中申请一个Chunk，结果返回指向该Chunk的指针或者NULL（如果失败），类似malloc()。
- 内存片的释放(Free) ：把从某个内存池中申请的Chunk返回给该内存池，供后来的申请者继续使用，类似free()。
- 内存片的重新分配(Realloc）：调用者嫌手里的Chunk尺寸不合适，还给内存池，再从内存池里面申请一个大小合适的新Chunk。
- 内存池的删除(Delete) : 彻底销毁该内存池，其中的Block一个不留，也包括初始Block。内存池删除后，指向该内存池的指针就无效了。
- 内存池的重置(Reset) : 彻底销毁该内存池中除初始Block以外的所有Block，再把初始Block重置为该内存池刚创建(Create)时的初始状态。

## 内存池的相关数据结构

在PostgreSQL的内存池子系统中有几个数据结构：MemoryContext(内存上下文)，AllocSetContext(分配集合上下文)，AllocBlock/Block(内存块)和AllocChunk/Chunk(内存片)。初学者不容易搞明白它们的概念和之间关系。下面概述一下PostgreSQL内存池的一些特点和规律：
- 在PostgreSQL内存池中唯一通过malloc()/free()分配和释放内存的单位是Block。
- 在初始Block的头部是AllocSetContext结构，AllocSetContext的第一个成员变量是MemoryContext。AllocSetContext是控制头，控制内存池的分配和释放。MemoryContext是一种内存池管理的一种抽象设计，AllocSetContext则是MemoryContext的一种实现方式。MemoryContext还可以有其它内存策略的分配方式，但是AllocSetContext是它在PostgreSQL中的缺省实现，故而本章只讨论AllocSetContext的实现细节。AllocSetContext结构的第一个成员必须是Memorycontext，两者是包含和被包含的关系。所以一个指向AllocSetContext的指针，又可以被看做是指向MemoryContext的指针。
- Chunk是从Block里面切分的小内存片。调用者使用palloc()来申请Chunk，通过pfree()把Chunk归还给内存池。一个内存池包括一个或者多个Block，每一个Block中包含一个或者多个Chunk，但是整个内存池只有一个AllocSetContext(其中包括MemoryContext)，存在于初始Block的头部。
- 每一个Block都有一个指针变量aset指向初始Block头部的AllocSetContext结构。每一个Chunk的头部也有一个指针变量aset，当该Chunk不是空闲内存的时候，它的aset也指向初始Block头部的AllocSetContext结构。这样的设计可以保证从每一个Block和Chunk中都可以迅速地拿到内存池的控制头，以便进一步的操作。
- 多个PostgreSQL内存池形成树形结构，其根节点的内存池是TopMemoryContext，它在PostgreSQL实例运行的整个生命周期内都一直存在。

以上论述的具体含义，随着我们对相关数据结构和函数的源代码的分析，读者就会越来越搞明白。下面介绍一下PostgreSQL内存池的相关数据结构。

#### 内存上下文MemoryContextData

MemoryContextData是内存池的一种抽象的控制头，具体对内存池的创建、内存分配和释放、内存池的销毁等工作由具体的下一层的控制头来实现，在PostgreSQL中就是AllocSetContext。MemoryContextData的定义如下：
```c
/* in src/include/nodes/memnodes.h */
typedef struct MemoryContextData {
    NodeTag         type;                   /* identifies exact kind of context */
    bool            isReset;                /* T = no space alloced since last reset */
    bool            allowInCritSection; /* allow palloc in critical section */
    Size            mem_allocated;  /* 本内存池中所有已经分配的内存的大小, in byte */
    const MemoryContextMethods *methods;    /* 本池的相关内存分配释放的函数指针 */
    MemoryContext parent;           /* NULL if no parent (toplevel context) */
    MemoryContext firstchild;       /* head of linked list of children */
    MemoryContext prevchild;        /* previous child of same parent */
    MemoryContext nextchild;        /* next child of same parent */
    const char *name;                       /* context name (just for debugging) */
    const char *ident;                      /* context ID if any (just for debugging) */
    MemoryContextCallback *reset_cbs;       /* list of reset/delete callbacks */
} MemoryContextData;
/* in src/include/utils/palloc.h */
typedef struct MemoryContextData *MemoryContext;
```
MemoryContextData的重要成员变量的含义如下：
- type - 内存池的类型，目前没有太大的意义。
- isReset - 该内存池是否被重置过。内存池被重置后焕然一新，其里面没有任何Chunk被分配出去，isReset为true。一旦有Chunk被分配出去，isRest就为false。
- mem_allocated - 本内存池所有已经通过malloc()分配的Block的大小之和，即本内存池的总体积。
- methods - 内存池创建销毁等操作的函数指针
- name - 用于调试内存池使用，平时用不到。它必须是一个常量字符串，如"MyPool"，不能是一个字符串变量。
- ident - 也是用于调试的时候使用，这里可以忽略。

我们观察到MemoryContextData有几个指针，parent/firstchild/prevchild/nextchild，通过它们，多个内存池可以形成了一个树形结构，如下图所示，其中每一个矩形都表示一个内存池。

![](d0024.svg)

我窃以为：prevchild和nextchild变量的名字起的不好。它们实际上指向了自己的兄弟，所以应该叫做pre_sibling和next_sibling。

在PostgreSQL中只有一个TopMemoryContext，它是处于根节点位置的内存池。在它下面还有若干内存池。它们使用如下的全局变量来进行记录：
```c
/* in src/backend/utils/mmgr/mcxt.c */
MemoryContext TopMemoryContext = NULL;      /* 根内存池的指针 */
MemoryContext CurrentMemoryContext = NULL; /* 当前内存池的指针 */

MemoryContext ErrorContext = NULL;
MemoryContext PostmasterContext = NULL;
MemoryContext CacheMemoryContext = NULL;
MemoryContext MessageContext = NULL;
MemoryContext TopTransactionContext = NULL;
MemoryContext CurTransactionContext = NULL;
```
这些内存池在PostgreSQL实例的生命周期内形成如下的树形结构：

![](d0026.svg)


#### 分配集上下文AllocSetContext

AllocSetContext是MemoryContext的具体实现，也是MemoryContext在PostgreSQL中的缺省实现方式。它的定义如下：
```c
/* in src/backend/utils/mmgr/aset.c */
typedef struct AllocSetContext {
    MemoryContextData header;	/* 第一个成员必须是MemoryContextData */
    /* Info about storage allocated in this context: */
    AllocBlock	blocks;	       /* 指向本内存池的活跃Block */
    AllocChunk  freelist[ALLOCSET_NUM_FREELISTS];  /* free chunk lists */
/* Allocation parameters for this context: */
    Size    initBlockSize;	/* initial block size */
    Size    maxBlockSize;	/* maximum block size */
    Size    nextBlockSize;	/* next block size to allocate */
    Size    allocChunkLimit;	/* effective chunk size limit */
    AllocBlock	keeper;			/* keep this block over resets */
/* freelist this context could be put in, or -1 if not a candidate: */
    int			freeListIndex;	/* index in context_freelists[], or -1 */
} AllocSetContext;

typedef AllocSetContext *AllocSet;
```
AllocSetContext的个成员变量的含义如下：
- header - MemoryContextData结构。其它方式的MemoryContextData的具体实现也必须把它设置为第一个成员。
- blocks - 指向本内存池内所有Block形成的双向链表的头部。
- freelist是一个数组，共计11个元素，它们指向空闲内存片AllocChunk的单向链表。具体含义后面会详细讨论。
- initBlockSize/maxBlockSizenextBlockSize - 三个控制Block体积的尺寸变量
- keeper - 指向初始Block。在内存池重置操作的时候通过它来判断哪一个Block是初始Block。
- freeListIndex - 后面有一小节来讨论它的作用。

#### 内存块AllocBlockData

AllocBlockData表示一个Block。每当内存池中分配一个新的Block的时候，它的头部就是AllocBlockData结构体。注意，初始Block不同，它的头部是AllocSetContext和AllocBlockData。初始Block和非初始Block的区别可以用下图来表示：

![](d0044.svg)

AllocBlockData的数据结构定义如下：
```c
/* in src/backend/utils/mmgr/aset.c */
typedef struct AllocBlockData {
    AllocSet    aset;	    /* 指向本内存池的初始Block头部的AllocSetContext */
    AllocBlock	prev;	    /* Block双向链表的向前指针 */
    AllocBlock	next;	    /* Block双向链表的向后指针 */
    char       *freeptr;    /* 本块空闲内存的起始地址 */
    char       *endptr;	    /* 本块的结束地址 */
}  AllocBlockData;
typedef struct AllocBlockData *AllocBlock;
```
AllocBlockData的各成员变量的含义比较简单，请参考上面的注释。freeptr和endptr表示本块空闲内存的首尾指针，则本块空闲内存的大小为endptr - freeptr。

#### 内存片AllocChunkData

AllocChunkData表示一个Chunk，翻译成中文可以称为“内存片”。每次调用palloc()从内存池中分配的内存都是一个Chunk，其释放是通过pfree()来完整的。它的数据结构非常简单：
```c
/* in src/backend/utils/mmgr/aset.c */
typedef struct AllocChunkData {
    Size    size;   /* 8 bytes in X64 */
    /* aset is the owning aset if allocated, or the freelist link if free */
    void    *aset;  /* 8 bytes in X64 */
    /* there must not be any padding to reach a MAXALIGN boundary here! */
} AllocChunkData;

typedef struct AllocChunkData *AllocChunk;
```
我们可以用下图来表示它的内存结构：

![](d0039.svg)

一个Chunk可以分配头部和真正的数据区。头部分为本Chunk的大小和一个指针aset，共计16个字节。Chunk的要点如下：
- size指的是真正数据的大小，不包括头部的16个字节。
- aset指针是“一鱼两吃”：当本Chunk已经被分配使用，aset指向初始Block头部的AllocSetContext。当本Chunk被pfree()释放会内存池中的时候，aset被用作在freelist中形成的单向链表中指向下一个成员的指针。这是程序设计上的一个小技巧，同一个指针在不同的情况下作为不同的用途。其具体含义我们在讨论freelist的时候再展开。
- palloc()申请的Chunk最终返回给调用者的指针是图中的p指针，不是Chunk的开头。
- aset指针和真正的数据之间是紧挨着的，不能有空隙。

为什么aset指针必须要和真正的数据紧挨着呢？这是因为我们往往需要根据p指针找到对应的Chunk头部，进而可以获得size和aset的信息。有时候也要根据Chunk指针获得指向真正数据的指针。在Chunk头部和指向数据的指针p之间没有空隙的话，只要把指针前后移动固定的位置就可以达到这个目的。请参考下面的相关操作的定义：
```c
/* in src/backend/utils/mmgr/aset.c */
#define ALLOC_CHUNKHDRSZ	     sizeof(struct AllocChunkData)
#define AllocPointerGetChunk(ptr)    ((AllocChunk)(((char *)(ptr)) - ALLOC_CHUNKHDRSZ))
#define AllocChunkGetPointer(chk)    ((AllocPointer)(((char *)(chk)) + ALLOC_CHUNKHDRSZ))

/* in src/backend/utils/mmgr/mcxt.c */
void pfree(void *pointer)
{
        MemoryContext context = GetMemoryChunkContext(pointer);
        context->methods->free_p(context, pointer);
}

/* in src/include/utils/memutils.h */
static inline MemoryContext GetMemoryChunkContext(void *pointer)
{
        MemoryContext context;
	/* 往前移动一个指针就可以拿到aset指针，指向MemoryContext */
        context = *(MemoryContext *) (((char *) pointer) - sizeof(void *)); 
        return context;
}
```
AllocPointerGetChunk是根据指向真正数据的指针ptr来获得指向AllocChunk的指针chk，其操作就是把ptr指针减16个字节就获得了，因为AllocChunkData结构的大小是16个字节(sizeof(struct AllocChunkData))。
```c
chk = ptr - sizeof(struct AllocChunkData) /* chk = ptr - 16 */
```
同样的道理，AllocChunkGetPointer是根据指向AllocChunk的指针chk获得指向真正数据的指针ptr。
```c
ptr = chk + sizeof(struct AllocChunkData) /* ptr = chk + 16 */
```
 理解了这些，大家对pfree()函数中的GetMemoryChunkContext就不难理解。

#### 空闲内存片数组freelist分析

在AllocSetContext结构里面有一个重要的成员变量freelist，它管理着通过pfree()释放回本内存池的Chunk。这些Chunk是空闲内存，但是却不可能被free()系统调用马上释放掉，因为必须整个Block才能被free()释放给操作系统。但是这些空闲的Chunk可以废物再利用，可以被未来的内存申请者所使用。所以每当有新的内存申请请求的时候，内存池首先会在freelist中寻找，找不到的时候再在Block中寻找。freelist是一个数组，共计11个成员，每一个成员都是一个AllocChunk指针。定义如下：
```c
/* in src/backend/utils/mmgr/aset.c */
#define ALLOCSET_NUM_FREELISTS	11
typedef struct AllocSetContext {
    ......
    AllocChunk  freelist[ALLOCSET_NUM_FREELISTS];
    ......
}
```
我们可以用下图来表示freelist的具体布局。

![](d0023.svg)

freelist[0]指向的Chunk，其体积统一为8个字节(真实数据的大小，不包括AllocChunk头部的16个字节)。freelist[1]指向的Chunk统一为16个字节大小，依次类推，最后一个成员freelist[10]指向的Chunk的体积统一为8192个字节。allocChunkLimit记录着freelist数组中Chunk的最大尺寸，它是一个阈值：当申请的内存的尺寸大于allocChunkLimit的时候，就无需在freelist数组中寻找了，而是直接申请新的Block。所以allocChunkLimit = 8192。其定义如下：
```c
/* in src/backend/utils/mmgr/aset.c */
#define ALLOC_MINBITS		3	/* smallest chunk size is 8 bytes */
#define ALLOCSET_NUM_FREELISTS	11
#define ALLOC_CHUNK_LIMIT	(1 << (ALLOCSET_NUM_FREELISTS-1+ALLOC_MINBITS))

/* in src/backend/utils/mmgr/aset.c:AllocSetContextCreateInternal */
    set->allocChunkLimit = ALLOC_CHUNK_LIMIT; /* ALLOC_CHUNK_LIMIT = 8192 */
```
假设用户要申请11个字节的内存，很显然它要在freelist[1]中找，因为这里的空闲Chunk的大小为16个字节。如果要申请60个字节，就在freelist[3]中寻找。这里面就有一个操作，根据内存的尺寸size寻找freelist数组的下标idx。其具体函数为：
```c
/* in src/backend/utils/mmgr/aset.c */
static inline int AllocSetFreeIndex(Size size)
{
int	idx;

    if (size > (1 << ALLOC_MINBITS)) { 
        /* 使用者必须确保size <= ALLOC_CHUNK_LIMIT，即size < = 8192 */
#ifdef HAVE__BUILTIN_CLZ
	idx = 31 - __builtin_clz((uint32) size - 1) - ALLOC_MINBITS + 1;
#else
	uint32		t,
				tsize;

	/* Statically assert that we only have a 16-bit input value. */
	StaticAssertStmt(ALLOC_CHUNK_LIMIT < (1 << 16),
					 "ALLOC_CHUNK_LIMIT must be less than 64kB");

	tsize = size - 1;
	t = tsize >> 8;
	idx = t ? pg_leftmost_one_pos[t] + 8 : pg_leftmost_one_pos[tsize];
	idx -= ALLOC_MINBITS - 1;
#endif

	Assert(idx < ALLOCSET_NUM_FREELISTS);
    }
    else idx = 0; /* size <= 8 就在freelist[0]中寻找 */

    return idx;
}

```

### PostgreSQL内存池的相关函数分析

#### 内存池操作的相关函数

```c
/* in src/include/nodes/memnodes.h */
typedef struct MemoryContextMethods {
    void    *(*alloc) (MemoryContext context, Size size);
    void     (*free_p) (MemoryContext context, void *pointer);
    void    *(*realloc) (MemoryContext context, void *pointer, Size size);
    void     (*reset) (MemoryContext context);
    void     (*delete_context) (MemoryContext context);
    Size     (*get_chunk_space) (MemoryContext context, void *pointer);
    bool     (*is_empty) (MemoryContext context);
    void     (*stats) (MemoryContext context,
		  MemoryStatsPrintFunc printfunc, void *passthru,
		  MemoryContextCounters *totals,
		  bool print_to_stderr);
} MemoryContextMethods;
```
在AllocSetContext中对应的实现函数如下：
```c
/* in src/backend/utils/mmgr/aset.c */
static const MemoryContextMethods AllocSetMethods = {
    AllocSetAlloc,
    AllocSetFree,
    AllocSetRealloc,
    AllocSetReset,
    AllocSetDelete,
    AllocSetGetChunkSpace,
    AllocSetIsEmpty,
    AllocSetStats
};
```
