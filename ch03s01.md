### 3.2 - PostgreSQL数据文件的结构

我们都知道对于所有的数据库而言，真正的数据是存放在数据文件中的。对于数据文件结构的理解，是我们学习更加深入知识的前提。在本节中，我们展开对PostgreSQL数据文件结构的基本分析工作。

#### 3.2.1 - 一个简单的实验

首先我们做一个简单的小实验，其过程如下所示：
```
$ id      /* 本实验以postgres用户直接登录到PG服务器上开始 */
uid=1000(postgres) gid=1000(postgres) groups=1000(postgres) ...
$ psql
psql (15.2)
Type "help" for help.

postgres=# CREATE DATABASE oracle;    /* 创建一个叫做oracle的数据库 */
CREATE DATABASE
postgres=# \c oracle                  /* 连接到oracle数据库中 */
You are now connected to database "oracle" as user "postgres".
oracle=# CREATE TABLE state(id INT, name CHAR(2));  /* 在oracle数据库中创建一个简单的表state，只有id和name两列 */
CREATE TABLE
oracle=# SELECT pg_relation_filepath('state'); /* 通过使用pg_relation_filepath()函数拿到表文件的路径 */
 pg_relation_filepath
----------------------
 base/16388/16389
(1 row)

oracle=# \! ls -l $PGDATA/base/16388/16389   /* 通过操作系统ls -l的命令查看这个文件在磁盘的信息 */
-rw------- 1 postgres postgres 0 Feb 24 14:38 /opt/data/pgdata1/base/16388/16389
/* 请注意上述文件的的大小，为0个字节，是因为这是一个空表，PG还没有为它分配真正的磁盘空间 */

oracle=# INSERT INTO state VALUES(0, 'TX'); /* 现在往state表中插入一条简单的记录 */
INSERT 0 1
oracle=# \! ls -l $PGDATA/base/16388/16389
-rw------- 1 postgres postgres 8192 Feb 24 14:40 /opt/data/pgdata1/base/16388/16389
/* 再次查看该数据文件，发现它的大小为8192个字节 */
```
在上述实验中，我用C语言的注释风格，用/* XXXX */来注释命令和输出结果的含义或者需要关注的要点。大家可以很清晰地看到，一个表对应磁盘上的一个文件，且该文件的名字是纯数字。当一个表拥有了第一个记录后，它的大小变成了8192个字节。为什么是8192个字节呢？这是因为PostgreSQL的数据文件是按照Block来划分的，每一个Block的大小都是8192个字节。在PostgreSQL的源码中，有一个常量BLCKSZ，它是Block Size的缩写。其定义如下：
```c
/* in src/include/pg_config.h */
#define BLCKSZ 8192
```

### 3.2.2 - Block/Page的结构分析

Block和Page是PostgreSQL世界里面经常互相替换使用的两个术语。我们已经有了一个基本概念，即PostgreSQL的数据文件是按照Block划分的，其缺省大小为8K（8 X 1024 = 8192个字节）。当磁盘上的一个Block被读入到内存中后，内存中也会分配8K的空间来保存它，称之为Page（页）。简而言之，在磁盘上是Block，在内存中则为Page，两者的内容是一模一样的。下面我们就来分析Block或者Page的基本结构。

我们可以把整个Page划分为四个区域：
- 头部区域，又称为Page Header（页头）
- 数据指针区域
- 数据区域
- 特殊区域

![](d0012.svg)
在上图中，两个带箭头的虚线表明数据指针区域和数据区域的增长方向。它们是相向而生长的。中间的空白部分是没有任何数据的空白区域。

#### 3.2.2.1 - 页头(Page Header)之分析

我们来研究一下Page Header的具体组成。它是一个C语言的结构体（struct），叫做PageHeaderData。其相关定义如下：
```c
/* in src/include/c.h */
#define FLEXIBLE_ARRAY_MEMBER   /* empty */
typedef uint32 TransactionId; /* 32-bit */

/* in src/include/storage/itemid.h */
typedef struct ItemIdData {
        unsigned  lp_off:15,              /* offset to tuple (from start of page) */
                  lp_flags:2,             /* state of line pointer, see below */
                  lp_len:15;              /* byte length of tuple */
} ItemIdData;

/* in src/include/storage/bufpage.h */
typedef struct {
        uint32          xlogid;          /* high bits */
        uint32          xrecoff;         /* low bits */
} PageXLogRecPtr;

typedef uint16 LocationIndex;

typedef struct PageHeaderData {
        PageXLogRecPtr pd_lsn;  /* LSN */
        uint16         pd_checksum;    /* checksum，用来校验本Page是否损坏 */
        uint16         pd_flags;       /* flag bits, see below */
        LocationIndex  pd_lower;       /* offset to start of free space */
        LocationIndex  pd_upper;       /* offset to end of free space */
        LocationIndex  pd_special;     /* offset to start of special space */
        uint16         pd_pagesize_version;
        TransactionId  pd_prune_xid; /* oldest prunable XID, or zero if none */
        ItemIdData     pd_linp[FLEXIBLE_ARRAY_MEMBER]; /* line pointer array */
} PageHeaderData;

```
PageHeaderData的重要成员变量介绍如下：
- pd_lsn是一个8个字节，表示LSN（Log Sequence Number）。LSN是PostgreSQL的核心概念，我们在第四章介绍WAL的时候再深入理解这个概念的含义。现在我们可以把它跳过去。
- pd_checksum是校验码，用于校验本Page是否损坏。
- pd_lower/pd_upper/pd_special是三个内部指针，指向本Page的各种关键位置信息。
- pd_pagesize_version记录了本Page的大小和PostgreSQL的版本信息。
- pd_prune_xid是事务ID
- pd_linp是一个可变长的数组，每个成员是4个字节，后面我们会讲解。


为了进一步理解PageHeaderData各成员变量的含义和整个Page的结构，我们可以参考下图：

![](d0004.svg)

#### 3.2.2.2 - 页头(Page Header)之分析
为了进一步理解PageHeaderData各成员变量的含义和整个Page的结构，我们可以参考下图：

***
如果你使用initdb创建数据库的时候，有一个参数-k可以打开数据库的校验码验证功能。或者在数据库创建完毕后使用pg_checksums工具来打开或者关闭校验码功能。我们也可以使用pg_controldata工具来查看本数据库是否打开了校验码验证功能。示例如下：
```
$ $PGHOME/bin/pg_controldata | grep checksum
Data page checksum version:           1    /* 1表示校验码功能已经打开，0则表示关闭 */
```

***

每条数据存储在 page 里，都对应一个数据指针和一个数据，数据指针记录了实际存储数据的位置。这种共享机制能够充分的利用空间，无论每条数据的是否过大或过小，都能几乎填满整个 page。


### Page头部

```c
typedef struct PageHeaderData
{
	PageXLogRecPtr pd_lsn;	// 该数据页最后一次被修改对应的wal日志的位置
	uint16		pd_checksum;	// 校检值
	uint16		pd_flags;	// 标记位
	LocationIndex pd_lower;	// 空闲空间的起始偏移量
	LocationIndex pd_upper;	// 空闲空间的结束偏移量
	LocationIndex pd_special;	// 特殊空间的结束偏移量
	uint16		pd_pagesize_version;	// page 格式版本号
	TransactionId pd_prune_xid; /* oldest prunable XID, or zero if none */
	ItemIdData	pd_linp[FLEXIBLE_ARRAY_MEMBER]; // 数据指针数组
} PageHeaderData;
```

整个结构如下图所示：

![d0001](https://github.com/itgotousa/pg16/blob/main/d0005.svg)

***
参考Link:
https://zhmin.github.io/posts/postgresql-buffer-page/
