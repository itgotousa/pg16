## 检查点 - CheckPoint

### 检查点(CheckPoint)的基本概念

检查点(CheckPoint)是数据库的重要概念，在第一节所展示的理论模型中，我们可以看到，为了恢复当前值18，如果我们只有基值6，就需要做七次加法运算。但是当我们把基值前移到了19，只需要做两次加法运算。为了加快对当前值的恢复，把基值从6前移到了19，这就是检查点概念的本质内容。在PostgreSQL中，检查点最主要的功能就是减少未来的数据库恢复时间。当一个检查点发生的时候，它会把内存中所有的脏页写回到磁盘上的数据文件中，这样的话，为了恢复当前状态，只需要检查点之后的WAL记录，而检查点之前的WAL记录就不再需要了。这大大减少的恢复数据库的时间。

检查点的触发条件有四种情况：
- 超级用户手工执行CHECKPOINT命令。
- 每隔一个固定的时间，PostgreSQL自动执行检查点。
- 每当WAL文件的体积超过一定大小的时候。
- 某一些特定操作，如开始备份，停机的时候。

### CheckPoint的WAL记录

CheckPoint的WAL记录的格式非常简单，只有两部分：记录头和数据，如下图所示：

![](d0032.svg)

这其中涉及到的数据结构如下：


下面我们用显微镜看一下一个WAL记录的原始内容。


### CheckPoint的执行过程

我们可以使用下图来展示CheckPoint的执行过程。在图中，水平实线表示各种对象，包括Checkpointer进程，Shared Buffer池，WAL Buffer，各种磁盘文件等等，其含义在左边对应列出。水平虚线分割上下两部分，上部分表示内存，下部分表示磁盘。

![](d0031.svg)

步骤(1)是CheckPoint发生的开始，此时Checkpointer进程会首先记录当前的WAL指针的位置，称为REDO point。紧接着步骤(2)开始在shared buffer池中寻找脏页，依次把这些脏页写入到磁盘的数据文件中。步骤(3)表示把脏页刷新到数据文件的过程。这个过程可能很长，持续几十分钟都不罕见。当所有的脏页被写入到数据文件以后，进入到了步骤(4)，它的动作是往WAL文件中插入一个CheckPoint的WAL记录。步骤(5)是把步骤(4)中的CheckPoint信息写入到控制文件.

我们可以参考下面的关键源代码

```c
/* in src/backend/access/transam/xlog.c:CreateCheckPoint() */

void CreateCheckPoint(int flags)
{
    ...
    curInsert = XLogBytePosToRecPtr(Insert->CurrBytePos);
    ...
    checkPoint.redo = curInsert;   /* 把当前WAL的位置记录在redo中 */
    ...
    /* CheckPointGuts函数是写脏页到数据文件中。它的执行时间最长 */
    CheckPointGuts(checkPoint.redo, flags); 
    ...
    XLogBeginInsert(); /* 这部分代码是执行步骤(4)，把CheckPoint WAL记录写入WAL文件中 */
    XLogRegisterData((char *) (&checkPoint), sizeof(checkPoint));
    recptr = XLogInsert(RM_XLOG_ID, shutdown ? XLOG_CHECKPOINT_SHUTDOWN : XLOG_CHECKPOINT_ONLINE);

    XLogFlush(recptr);
    ...
    UpdateControlFile();  /* 步骤(5)更新控制文件 */
    ...
}

```
下面我们来做一个小实验验证一下。
```
postgres=# \! $PGHOME/bin/pg_controldata -D $PGDATA | grep location | grep checkpoint
Latest checkpoint location:           0/3000148
Latest checkpoint's REDO location:    0/3000148
```
从上面的输出中可以看到REDO point是0/3000148。然后我们手工执行一个Checkpoint，再观察控制文件里面的相关信息
```
postgres=# checkpoint; /* 手工执行CHECKPOINT命令 */
CHECKPOINT
postgres=# \! $PGHOME/bin/pg_controldata -D $PGDATA | grep location | grep checkpoint
Latest checkpoint location:           0/3000230
Latest checkpoint's REDO location:    0/30001F8  /* REDO point已经前移了 */
```
我们发现执行检查点后的REDO point变成了0/30001F8，移动了176个字节(0x30001F8 - 0x3000148)。从这个实验中我们可以看到，每次CHECKPOINT成功以后，控制文件都会即时更新，获得最新的CheckPoint的位置。

```

```

定义如下：

![](d0034.svg)

```c
```
定义如下：

![](d0037.svg)


定义如下：
```c
```
定义如下：
```c
```
定义如下：
```c
```
定义如下：
```c
```
定义如下：
```c
```
定义如下：
```c
```
定义如下：
```c
```
定义如下：
```c
```
定义如下：
```c
```
定义如下：
```c
```
