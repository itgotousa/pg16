### 3.2 - PostgreSQL数据文件的结构

我们都知道对于所有的数据库而言，真正的数据是存放在数据文件中的。对于数据文件结构的理解，是我们学习更加深入知识的前提。在本节中，我们展开对PostgreSQL数据文件结构的基本分析工作。首先我们做一个简单的小实验，其过程如下所示：
```
$ id      /* 本实验以postgres用户直接登录到PG服务器上开始 */
uid=1000(postgres) gid=1000(postgres) groups=1000(postgres) ...
$ psql
psql (15.2)
Type "help" for help.

postgres=# CREATE DATABASE oracle;    /* 创建一个叫做oracle的数据库 */
CREATE DATABASE
postgres=# \c oracle                  /* 连接到oracle数据库中 */
You are now connected to database "oracle" as user "postgres".
oracle=# CREATE TABLE state(id INT, name CHAR(2));  /* 在oracle数据库中创建一个简单的表state，只有id和name两列 */
CREATE TABLE
oracle=# SELECT pg_relation_filepath('state'); /* 通过使用pg_relation_filepath()函数拿到表文件的路径 */
 pg_relation_filepath
----------------------
 base/16388/16389
(1 row)

oracle=# \! ls -l $PGDATA/base/16388/16389   /* 通过操作系统ls -l的命令查看这个文件在磁盘的信息 */
-rw------- 1 postgres postgres 0 Feb 24 14:38 /opt/data/pgdata1/base/16388/16389
/* 请注意上述文件的的大小，为0个字节，是因为这是一个空表，PG还没有为它分配真正的磁盘空间 */

oracle=# INSERT INTO state VALUES(0, 'TX'); /* 现在往state表中插入一条简单的记录 */
INSERT 0 1
oracle=# \! ls -l $PGDATA/base/16388/16389
-rw------- 1 postgres postgres 8192 Feb 24 14:40 /opt/data/pgdata1/base/16388/16389
/* 再次查看该数据文件，发现它的大小为8192个字节 */
```
在上述实验中，我用C语言的注释风格，用/* XXXX */来注释命令和输出结果的含义或者需要关注的要点。大家可以很清晰地看到，一个表对应磁盘上的一个文件，且该文件的名字是纯数字。当一个表拥有了第一个记录后，它的大小变成了8192个字节。为什么是8192个字节呢？这是因为PostgreSQL的数据文件是按照Block来划分的，每一个Block的大小都是8192个字节。在PostgreSQL的源码中，有一个常量BLCKSZ，它是Block Size的缩写。其定义如下：
```c
/* in src/include/pg_config.h */
#define BLCKSZ 8192
```

一个Page大小通常为8Kb，也就是8192个字节。我们可以把整个Page划分为四个区域：
- Page头部区域
- 数据指针区域
- 数据区域
- 特殊区域

如下图所示意：

![d0001](https://github.com/itgotousa/pg16/blob/main/d0004.svg)

其中数据指针区域和数据区域是空间共享的，数据指针区域的区间是从上面开始的，向下扩展。而数据区域的空间方向是相反的，从下面开始的，向上扩展。

每条数据存储在 page 里，都对应一个数据指针和一个数据，数据指针记录了实际存储数据的位置。这种共享机制能够充分的利用空间，无论每条数据的是否过大或过小，都能几乎填满整个 page。


### Page头部

```c
typedef struct PageHeaderData
{
	PageXLogRecPtr pd_lsn;	// 该数据页最后一次被修改对应的wal日志的位置
	uint16		pd_checksum;	// 校检值
	uint16		pd_flags;	// 标记位
	LocationIndex pd_lower;	// 空闲空间的起始偏移量
	LocationIndex pd_upper;	// 空闲空间的结束偏移量
	LocationIndex pd_special;	// 特殊空间的结束偏移量
	uint16		pd_pagesize_version;	// page 格式版本号
	TransactionId pd_prune_xid; /* oldest prunable XID, or zero if none */
	ItemIdData	pd_linp[FLEXIBLE_ARRAY_MEMBER]; // 数据指针数组
} PageHeaderData;
```

整个结构如下图所示：

![d0001](https://github.com/itgotousa/pg16/blob/main/d0005.svg)

***
参考Link:
https://zhmin.github.io/posts/postgresql-buffer-page/
