# PostgreSQL的共享内存结构分析

在共享内存的最开始，是一个PGShmemHeader的结构，其定义如下
```C
typedef struct PGShmemHeader    /* standard header for all Postgres shmem */
{
        int32           magic;                  /* magic # to identify Postgres segments */
#define PGShmemMagic  679834894
        pid_t           creatorPID;             /* PID of creating process (set but unread) */
        Size            totalsize;              /* total size of segment */
        Size            freeoffset;             /* offset to first free space */
        dsm_handle      dsm_control;    /* ID of dynamic shared memory control seg */
        void       *index;                      /* pointer to ShmemIndex table */
#ifndef WIN32                                   /* Windows doesn't have useful inode#s */
        dev_t           device;                 /* device data directory is on */
        ino_t           inode;                  /* inode number of data directory */
#endif
} PGShmemHeader;
```
PGShmemHeader的各个数据成员的含义如下：
- magic       ：写死为679834894，被称为魔幻数。它只是作为特征码标记PG的共享内存。
- creatorPID  ：创建这个共享内存的进程的PID，就是Postgres主进程的PID
- totalsize   ：记录共享内存的大小，它的单位是字节(byte)
- freeoffset  : 偏移量，表示本共享内存块未分配的空间的起始地址。每次分配新的数据，freeoffset不断增加
- dsm_control :
- index
- device
- inode

其结构可以参考下图：
![](d0016.svg)

如上图所示，PostgreSQL定义了三个指针变量，分别指向共享内存的开头和结尾。这三个变量的定义如下：
```C
/* src/backend/storage/ipc/shmem.c */

/* shared memory global variables */

static PGShmemHeader *ShmemSegHdr;      /* shared mem segment header */

static void *ShmemBase;                 /* start address of shared memory */

static void *ShmemEnd;                  /* end+1 address of shared memory */

```

在InitShmemAccess函数中，对这三个指针变量进行了设定。源码如下：

```C

/*
 *      InitShmemAccess() --- set up basic pointers to shared memory.
 *
 * Note: the argument should be declared "PGShmemHeader *seghdr",
 * but we use void to avoid having to include ipc.h in shmem.h.
 */
void
InitShmemAccess(void *seghdr)
{
        PGShmemHeader *shmhdr = (PGShmemHeader *) seghdr; /* 指向共享内存的开始*/

        ShmemSegHdr = shmhdr;
        ShmemBase = (void *) shmhdr;
        ShmemEnd = (char *) ShmemBase + shmhdr->totalsize;
}
```

上述代码非常简洁明了，无需多言。对InitShmemAccess的调用是在./backend/postmaster/postmaster.c里面：

```C
                /* Restore basic shared memory pointers */
                InitShmemAccess(UsedShmemSegAddr);

```
而的初始化是在./backend/port/sysv_shmem.c中可以找到：
```C

void       *UsedShmemSegAddr = NULL;

/* Save info for possible future use */
        UsedShmemSegAddr = memAddress;
        UsedShmemSegID = (unsigned long) NextShmemSegID;
```




当程序想访问共享内存的某一个结构时，首先拿到ShmemSegHdr或者ShmemBase的指针，然后根据ShmemSegHdr->index指向的Hash表进行搜索。这个我们后面会详细分析。

在典型的情况下，PostgreSQL有两块共享内存。一块是由mmap()创建，ShmemSegHdr指针指向其起始位置。这是最核心的共享内存。另外一块是由shmget()创建的System V的共享内存。它非常小，尺寸只有sizeof(PGShmemHeader)，在我的实验环境中只有56个字节。它由UsedShmemSegAddr指针指向其起始位置。

搞清楚上面的基本结构，我们来分析ShmemAllocRaw函数，就很容易理解代码的含义了。
```C
/* src/backend/storage/ipc/shmem.c */
/*
 * ShmemAllocRaw -- allocate align chunk and return allocated size
 *
 * Also sets *allocated_size to the number of bytes allocated, which will
 * be equal to the number requested plus any padding we choose to add.
 */
static void *
ShmemAllocRaw(Size size, Size *allocated_size)
{
        Size            newStart;
        Size            newFree;
        void       *newSpace;

        /*
         * Ensure all space is adequately aligned.  We used to only MAXALIGN this
         * space but experience has proved that on modern systems that is not good
         * enough.  Many parts of the system are very sensitive to critical data
         * structures getting split across cache line boundaries.  To avoid that,
         * attempt to align the beginning of the allocation to a cache line
         * boundary.  The calling code will still need to be careful about how it
         * uses the allocated space - e.g. by padding each element in an array of
         * structures out to a power-of-two size - but without this, even that
         * won't be sufficient.
         */
        size = CACHELINEALIGN(size); /* 为了提高性能，内存边界按照8字节对齐 */
        *allocated_size = size;      /* 保存对齐后的新的size值 */

        Assert(ShmemSegHdr != NULL);

        SpinLockAcquire(ShmemLock);

        newStart = ShmemSegHdr->freeoffset;  /* newStart是共享内存的空闲地址的起点 */

        newFree = newStart + size;   /* 调整新的共享内存的空闲地址的起点 */
        if (newFree <= ShmemSegHdr->totalsize) /* 新的空闲地址的偏移量没有超过整个共享内存的大小，就OK*/
        {
                newSpace = (void *) ((char *) ShmemBase + newStart);  /* ShmemSegHdr + newStart就是指向刚刚成功分配内存的指针 !!! */
                ShmemSegHdr->freeoffset = newFree; /* 调整freeoffset指向新的空闲地址的偏移量 */
        }
        else /* 申请新内存的size太大了，超过了边界，拒绝分配，直接返回NULL指针 */
                newSpace = NULL;

        SpinLockRelease(ShmemLock);

        /* note this assert is okay with newSpace == NULL */
        Assert(newSpace == (void *) CACHELINEALIGN(newSpace)); /* 确保返回的指针是按照8字节对齐的，利于提高性能，请搜索CPU cache line boundary了解其概念 */

        return newSpace; 
}

```
相信大家有了上图的概念，对ShmemAllocRaw函数的基本流程有了比较清晰的理解了。

