## PostgreSQL数据文件的结构

我们都知道对于所有的数据库而言，真正的数据是存放在数据文件中的。对于数据文件结构的理解，是我们学习更加深入知识的前提。在本节中，我们展开对PostgreSQL数据文件结构的基本分析工作。

### 一个简单的实验

首先我们做一个简单的小实验，其过程如下所示：
```
$ id      /* 本实验以postgres用户直接登录到PG服务器上开始 */
uid=1000(postgres) gid=1000(postgres) groups=1000(postgres) ...
$ psql
psql (15.2)
Type "help" for help.

postgres=# CREATE DATABASE oracle;    /* 创建一个叫做oracle的数据库 */
CREATE DATABASE
postgres=# \c oracle                  /* 连接到oracle数据库中 */
You are now connected to database "oracle" as user "postgres".
oracle=# CREATE TABLE state(id INT, name CHAR(2));  /* 在oracle数据库中创建一个简单的表state，只有id和name两列 */
CREATE TABLE
oracle=# SELECT pg_relation_filepath('state'); /* 通过使用pg_relation_filepath()函数拿到表文件的路径 */
 pg_relation_filepath
----------------------
 base/16388/16389
(1 row)

oracle=# \! ls -l $PGDATA/base/16388/16389   /* 通过操作系统ls -l的命令查看这个文件在磁盘的信息 */
-rw------- 1 postgres postgres 0 Feb 24 14:38 /opt/data/pgdata1/base/16388/16389
/* 请注意上述文件的的大小，为0个字节，是因为这是一个空表，PG还没有为它分配真正的磁盘空间 */

oracle=# INSERT INTO state VALUES(0, 'TX'); /* 现在往state表中插入一条简单的记录 */
INSERT 0 1
oracle=# \! ls -l $PGDATA/base/16388/16389
-rw------- 1 postgres postgres 8192 Feb 24 14:40 /opt/data/pgdata1/base/16388/16389
/* 再次查看该数据文件，发现它的大小为8192个字节 */
```
大家可以很清晰地看到，一个表对应磁盘上的一个文件，且该文件的名字是纯数字。当一个表拥有了第一个记录后，它的大小变成了8192个字节。为什么是8192个字节呢？这是因为PostgreSQL的数据文件是按照Block来划分的，每一个Block的大小都是8192个字节。在PostgreSQL的源码中，有一个常量BLCKSZ，它是Block Size的缩写。其定义如下：
```c
/* in src/include/pg_config.h */
#define BLCKSZ 8192
```

### Block/Page的结构分析

Block和Page是PostgreSQL世界里面经常互相替换使用的两个术语。我们已经有了一个基本概念，即PostgreSQL的数据文件是按照Block划分的，其缺省大小为8K（8 X 1024 = 8192个字节）。当磁盘上的一个Block被读入到内存中后，内存中也会分配8K的空间来保存它，称之为Page（页）。简而言之，在磁盘上是Block，在内存中则为Page，两者的内容是一模一样的。下面我们就来分析Block或者Page的基本结构。

我们可以把整个Page划分为四个区域：
- 头部区域，又称为Page Header（页头）
- 数据指针区域
- 数据区域
- 特殊区域


Block/Page的整体结构可以用下图来表示：

![](d0012.svg)

在上图中，两个带箭头的虚线表明数据指针区域和数据区域的增长方向。它们是相向而生长的。中间的空白部分是没有任何数据的空白区域。

### 页头(Page Header)之分析

我们来研究一下Page Header的具体组成。它是一个C语言的结构体（struct），叫做PageHeaderData。其相关定义如下：
```c
/* in src/include/c.h */
#define FLEXIBLE_ARRAY_MEMBER   /* empty */
typedef uint32 TransactionId; /* 32-bit */

/* in src/include/storage/itemid.h */
typedef struct ItemIdData {
        unsigned  lp_off:15,              /* offset to tuple (from start of page) */
                  lp_flags:2,             /* state of line pointer, see below */
                  lp_len:15;              /* byte length of tuple */
} ItemIdData;

/* in src/include/storage/bufpage.h */
typedef struct {
        uint32          xlogid;          /* high bits */
        uint32          xrecoff;         /* low bits */
} PageXLogRecPtr;

typedef uint16 LocationIndex;

typedef struct PageHeaderData {
        PageXLogRecPtr pd_lsn;  /* LSN */
        uint16         pd_checksum;    /* checksum，用来校验本Page是否损坏 */
        uint16         pd_flags;       /* flag bits, see below */
        LocationIndex  pd_lower;       /* offset to start of free space */
        LocationIndex  pd_upper;       /* offset to end of free space */
        LocationIndex  pd_special;     /* offset to start of special space */
        uint16         pd_pagesize_version;
        TransactionId  pd_prune_xid; /* oldest prunable XID, or zero if none */
        ItemIdData     pd_linp[FLEXIBLE_ARRAY_MEMBER]; /* line pointer array */
} PageHeaderData;

```
PageHeaderData的重要成员变量介绍如下：
- pd_lsn是一个8个字节，表示LSN（Log Sequence Number）。LSN是PostgreSQL的核心概念，我们在第四章介绍WAL的时候再深入理解这个概念的含义。现在我们可以把它跳过去。
- pd_checksum是校验码，用于校验本Page是否损坏。
- pd_lower/pd_upper/pd_special是三个内部指针，指向本Page的各种关键位置信息。
- pd_pagesize_version记录了本Page的大小和PostgreSQL的版本信息。
- pd_prune_xid是事务ID，以后会介绍。现在可以忽略。
- pd_linp是一个可变长的数组，每个成员是4个字节，后面我们会讲解。


为了进一步理解PageHeaderData各成员变量的含义和整个Page的结构，我们可以参考下图：

![](d0029.svg)

pd_lower/pd_upper/pd_special都是16-bit的无符号整数，它们是相对的偏移量。pd_lower指向了空白区域的起点，pd_upper指向了空白区域的终点。pd_special指向了特殊区域的起点。假设一个指针 char* p指向了某一个Page的开始，则 p + pd_lower就是指向本Page空白区域的起始位置，新的数据插入的位置就很容易计算出来了。

因为这三个本地指针都是16-bit，所以它们的最大长度是2^16 = 64KB。这也是PostgreSQL在目前的数据结构下Block/Page的最大尺寸。但是在ItemIdData里面的指针lp_off是15-bit，所以它能够寻址的空间是2^15 = 32KB。所以我们说PostgreSQL的Block和Page最大可以设置为32KB，但是通常我们都选择缺省的8KB，这是对OLTP事务性数据库和OLAP分析性数据库比较折中和平衡的设置。Oracle/Microsoft SQL Server缺省的Page尺寸也是8KB。

```c
typedef uint16 OffsetNumber;
/* in src/include/storage/block.h */
typedef struct BlockIdData {
    uint16          bi_hi;
    uint16          bi_lo;
} BlockIdData;

/* in src/include/storage/itemptr.h */
typedef struct ItemPointerData {
    BlockIdData ip_blkid;
    OffsetNumber ip_posid;
} ItemPointerData;
```
BlockIdData是4字节，标识一个表的数据文件的Block号，所以在BLCKSZ = 8K的情况下，一个表最大的体积是4G X 8K = 32T。你可以把BLCKSZ设置为32K，则最大的表的体积是128T。

hexdump是一个把任何文件的内容以16进制的格式显示的工具，是万能的，也是最暴力分析工具。我们也可以使用hexdump来直接把在3.2.1小节中产生的数据文件dump出来，用于验证PageHeaderData的各成员变量。具体操作如下：
```
postgres=# CHECKPOINT;  /* 为了确保数据真正写入磁盘，我们手工执行一下检查点 */
CHECKPOINT              /* 检查点checkpoint的概念我们在下一章进行介绍 */
postgres=# \! hexdump -C $PGDATA/base/16388/16389
00000000  00 00 00 00 28 9a b0 01  31 cf 00 00 1c 00 e0 1f  |....(...1.......|
00000010  00 20 04 20 00 00 00 00  e0 9f 3e 00 00 00 00 00  |. . ......>.....|
00000020  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*         /* 这行的星号表示重复上一行的内容很多次，减少屏幕上的输出 */ 
00001fe0  e0 02 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00001ff0  01 00 02 00 02 08 18 00  00 00 00 00 07 54 58 00  |.............TX.|
00002000
```
拿到上述数据，我们稍微耐心一点就可以分析出各个成员变量的值。
- pd_lsn =
- pd_lsn =

这个实验和分析可以展示Block的最原始的面目，让我们对Block的各个结构有了更加实在的体验。

### HeapTupleHeaderData之分析

为了进一步理解PageHeaderData各成员变量的含义和整个Page的结构，我们可以参考下图：


### 分析Block/Page结构的工具

为了分析Block/Page的内容，PostgreSQL提供了两个工具: pageinspect和pg_filedump。本节介绍这两个工具的基本使用。当然，hexdump也是我们工具箱里面不可或缺的工具。

#### Page分析工具pageinspect

为了分析Block/Page的内容，PostgreSQL提供了两个工具: pageinspect和pg_filedump。本节介绍这两个工具的基本使用。当然，，也是我们工具箱里面不可或缺的工具。
```
postgres=# select * from pg_extension;
  oid  | extname | extowner | extnamespace | extrelocatable | extversion | extconfig | extcondition
-------+---------+----------+--------------+----------------+------------+-----------+--------------
 12755 | plpgsql |       10 |           11 | f              | 1.0        |           |
(1 row)

postgres=# CREATE EXTENSION pageinspect;
CREATE EXTENSION
postgres=# select * from pg_extension;
  oid  |   extname   | extowner | extnamespace | extrelocatable | extversion | extconfig | extcondition
-------+-------------+----------+--------------+----------------+------------+-----------+--------------
 12755 | plpgsql     |       10 |           11 | f              | 1.0        |           |
 16392 | pageinspect |       10 |         2200 | t              | 1.11       |           |
(2 rows)

postgres=#
```
#### 再来一个pg_buffercache

为了分析Block/Page的内容，PostgreSQL提供了两个工具: pageinspect和pg_filedump。本节介绍这两个工具的基本使用。当然，hexdump是一个把任何文件的内容以16进制的格式显示的工具，是万能的，也是最暴力分析工具，也是我们工具箱里面不可或缺的工具。


#### Block分析工具pg_filedump

为了分析Block/Page的内容，PostgreSQL提供了两个工具: pageinspect和pg_filedump。本节介绍这两个工具的基本使用。当然，hexdump是一个把任何文件的内容以16进制的格式显示的工具，是万能的，也是最暴力分析工具，也是我们工具箱里面不可或缺的工具。

### 表空间

在这个小节介绍表空间的概念。


***
参考Link:
https://zhmin.github.io/posts/postgresql-buffer-page/

***
如果你使用initdb创建数据库的时候，有一个参数-k可以打开数据库的校验码验证功能。或者在数据库创建完毕后使用pg_checksums工具来打开或者关闭校验码功能。我们也可以使用pg_controldata工具来查看本数据库是否打开了校验码验证功能。示例如下：
```
$ $PGHOME/bin/pg_controldata | grep checksum
Data page checksum version:           1    /* 1表示校验码功能已经打开，0则表示关闭 */
```
