#### 函数AllocSetAlloc分析

AllocSetAlloc函数承担了处理从内存池中分配Chunk的主要工作，如果分配成功就返回分配的内存，否则返回NULL。每当内存池接受了调用者发来的内存申请，内存池采用如下的分配策略来寻找合适的内存片：
1. 内存池有一个申请内存的阈值allocChunkLimit。当调用者申请的内存尺寸超过这个阈值，就简单通过malloc()分配一个Block给调用者，且把这个Block挂在头部Block后面。我们称这个整个Block只有一个内存片的Chunk为单块Chunk。
2. 在申请的内存尺寸小于该阈值的时候，内存池会首先在freelist数组中寻找可能合适的空闲内存，如果找到了就把内存片的指针返回给调用者。
3. 如果找不到，就在blocks指向的Block链表头部的那个Block中寻找空闲空间，找到后就把内存片的指针返回给调用者。
4. 如果在头部Block中找不到，就再申请一个新的Block，其体积往往是当前头部Block的两倍，直至其尺寸达到了maxBlockSize后就不再增加了。

单块Chunk可以用如下图来表示。

![](d0045.svg)

从图中可以看到，对于一个chunk，如果它的size大于allocChunkLimit，就可以判断它为单块chunk。把chunk指针往低地址移动ALLOC_BLOCKHDRSZ个字节就可以拿到它所在的Block的指针了。这个Chunk是直接使用malloc()分配的，对它的释放自然也是用free()。
```c
/* in src/backend/utils/mmgr/aset.c */
#define ALLOC_BLOCKHDRSZ	MAXALIGN(sizeof(AllocBlockData))
```
ALLOC_BLOCKHDRSZ是把AllocBlockData结构按照8字节做齐。


```c
/* in src/backend/utils/mmgr/aset.c */
static void * AllocSetAlloc(MemoryContext context, Size size)
{
AllocSet	set = (AllocSet) context;
AllocBlock	block;
AllocChunk	chunk;
int		fidx;
Size		chunk_size;
Size		blksize;

}
```

我们先分析第一种情况的代码流程：
```c
/* in src/backend/utils/mmgr/aset.c */
static void * AllocSetAlloc(MemoryContext context, Size size)
{
AllocSet	set = (AllocSet) context;
AllocBlock	block;
AllocChunk	chunk;
int		fidx;
Size		chunk_size;
Size		blksize;

    /* 如果请求分配的内存大小超过阈值，就直接调用malloc分配一个整块 */
    if (size > set->allocChunkLimit) {
        chunk_size = MAXALIGN(size); /* 先把尺寸按照8字节做齐 */
/* 每一个块要有一个头部ALLOC_BLOCKHDRSZ。而且本块只有一个Chunk，所以也要加一个ALLOC_CHUNKHDRSZ */
        blksize = chunk_size + ALLOC_BLOCKHDRSZ + ALLOC_CHUNKHDRSZ;
        block = (AllocBlock) malloc(blksize); /* 直接调用malloc()进行真是的内存分配 */
        if (block == NULL) return NULL; /* 分配失败就返回NULL */

        context->mem_allocated += blksize; /* 调整本set中以分配内存的总体尺寸 */
        /* 把本block的aset指针指向本set的AllocSetContext */
	block->aset = set;
	/* 因为本块整个算一个Chunk，所以没有空闲空间了，调整一下首位指针指向尾部 */
	block->freeptr = block->endptr = ((char *) block) + blksize;

	chunk = (AllocChunk) (((char *) block) + ALLOC_BLOCKHDRSZ);
	chunk->aset = set;
	chunk->size = chunk_size;
        if (set->blocks != NULL) {
		block->prev = set->blocks;
		block->next = set->blocks->next;
		if (block->next) block->next->prev = block;
		set->blocks->next = block;
	} else {
		block->prev = NULL;
		block->next = NULL;
		set->blocks = block;
	}
	return AllocChunkGetPointer(chunk);
    }
    ...
}

```
上述代码走完后，其内存布局如下图所示：

![](d0041.svg)

![](d0042.svg)

#### 函数AllocSetContextCreate分析

#### 函数AllocSetContextCreate分析

#### 函数AllocSetContextCreate分析

#### 函数AllocSetContextCreate分析

#### 函数AllocSetContextCreate分析

#### 函数AllocSetContextCreate分析

#### 函数AllocSetContextCreate分析
当完成初始化后，它的内存分配如图所示.

当完成初始化后，它的内存分配如图所示.

当完成初始化后，它的内存分配如图所示.

