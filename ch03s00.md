# 第三章 - 数据文件

数据库软件最主要的工作是保存数据，查询数据。数据是保存在数据文件(Data File)里面的。数据库可以按行存储数据，也可以按列存储数据，由此产生了行式数据库（Row Oriented Databases）和列式数据库（Columnar Database）两种类型。传统的关系型数据库，包括Oracle,Microsoft SQL Server, MySQL和PostgreSQL都是行式数据库。在本章，我们来对PostgreSQL的数据文件的结构进行研究。

从本章开始，我们要一边学习PostgreSQL的外在功能，同时要阅读和理解PostgreSQL的源代码。我们先对PostgreSQL源代码的基本知识做一些介绍。

## 关于PostgreSQL源代码的基础知识

我们在第一章中学习了如何通过下载和编译PostgreSQL的源码包完成PostgreSQL数据库软件的安装。在源码里面，有一个src子目录和一个contrib子目录。src子目录中包含全部的PostgreSQL的核心源代码。contrib子目录中包含了外围工具的源代码。当我引用某些数据结构和源代码的时候，我会用类似/* in src/include/storage/bufpage.h */ 的注释来标注所引用的数据结构和代码是在文件bufpage.h中定义的，这是一个相对路径。假设我们的源代码目录是/home/postgres/postgresql-15.2，则bufpage.h文件的绝对路径就是：/home/postgres/postgresql-15.2/src/include/storage/bufpage.h。这样方便大家直接打开该文件进行查找和阅读。

### 配置头文件

在源码包中，有一些头文件里面定义了大量的宏，用来控制源码的编译行为，如src/include/pg_config_manual.h。我们可以称之为配置头文件。有三个配置pg_config.h，pg_config_os.h和pg_config_ext.h是不在源码包中的。你必须运行configure命令后，configure根据对操作系统环境的检测，自动生成这三个文件，放在src/include目录下。所以如果你发现无法找到某些宏的定义的时候，可以运行configure命令产生这三个配置头文件。可能你要找的宏就在这三个头文件中。

### 基本数据类型

在PostgreSQL源代码中使用了大量的基础数据，我们需要提前熟悉这些基础数据类型。
```c
/* in src/include/c.h */
typedef signed char int8;               /* == 8 bits */
typedef signed short int16;             /* == 16 bits */
typedef signed int int32;               /* == 32 bits */

typedef unsigned char uint8;    /* == 8 bits */
typedef unsigned short uint16;  /* == 16 bits */
typedef unsigned int uint32;    /* == 32 bits */

typedef uint8 bits8;                    /* >= 8 bits */
typedef uint16 bits16;                  /* >= 16 bits */
typedef uint32 bits32;                  /* >= 32 bits */

typedef long int int64;
typedef unsigned long int uint64;

typedef size_t Size; /* 8 bytes in 64-bit Linux */
```
大家很容易熟悉上面各种自定义的基础数据类型的命名规律。intXX是有符号整数，可以表示负数和正数。uintXX是无符号整数，只能表示正数，最小值为0。其中XX为8,16,32,64，表示这个数据类型有多少个比特(bit)。Size也是在源码中被大量使用的一个基础数据类型。在64位平台上它有8个字节的长度。

### 对源代码文件的搜索

在本书写作的时候，PostgreSQL已经有了一百多万行的源代码，分布在2000多个*.h和*.c文件中。当我们研读一个数据结构，一个函数的时候，我们非常想快速搜索到它的定义所在的文件。我喜欢使用一种暴力搜索方式，如下所示：
```
$ pwd
/home/postgres/postgresql-15.2/src

/* 在当前目录和子目录中的所有*.h文件中搜索字符串 PageHeaderData */
$ find . -name *.h | xargs grep PageHeaderData

/* 在当前目录和子目录中的所有*.c文件中搜索字符串 ShmemInitStruct */
$ find . -name *.c | xargs grep ShmemInitStruct
```
当然，你可以在网上找到一些源码索引软件。doxygen.postgresql.org是PostgreSQL官方提供的在线源码阅读网站，使用也非常方便。

### 内存对齐
为了提高软件的运行效率

```c
/* in src/include/storage/bufpage.h */
typedef struct PageHeaderData
{
        /* XXX LSN is member of *any* block, not only page-organized ones */
        PageXLogRecPtr pd_lsn;          /* LSN: next byte after last byte of xlog
                                                                 * record for last change to this page */
        uint16          pd_checksum;    /* checksum */
        uint16          pd_flags;               /* flag bits, see below */
        LocationIndex pd_lower;         /* offset to start of free space */
        LocationIndex pd_upper;         /* offset to end of free space */
        LocationIndex pd_special;       /* offset to start of special space */
        uint16          pd_pagesize_version;
        TransactionId pd_prune_xid; /* oldest prunable XID, or zero if none */
        ItemIdData      pd_linp[FLEXIBLE_ARRAY_MEMBER]; /* line pointer array */
} PageHeaderData;

```

一个Page大小通常为8Kb，也就是8192个字节。我们可以把整个Page划分为四个区域：
- Page头部区域
- 数据指针区域
- 数据区域
- 特殊区域

如下图所示意：

![d0001](https://github.com/itgotousa/pg16/blob/main/d0004.svg)

其中数据指针区域和数据区域是空间共享的，数据指针区域的区间是从上面开始的，向下扩展。而数据区域的空间方向是相反的，从下面开始的，向上扩展。

每条数据存储在 page 里，都对应一个数据指针和一个数据，数据指针记录了实际存储数据的位置。这种共享机制能够充分的利用空间，无论每条数据的是否过大或过小，都能几乎填满整个 page。


### Page头部

```c
typedef struct PageHeaderData
{
	PageXLogRecPtr pd_lsn;	// 该数据页最后一次被修改对应的wal日志的位置
	uint16		pd_checksum;	// 校检值
	uint16		pd_flags;	// 标记位
	LocationIndex pd_lower;	// 空闲空间的起始偏移量
	LocationIndex pd_upper;	// 空闲空间的结束偏移量
	LocationIndex pd_special;	// 特殊空间的结束偏移量
	uint16		pd_pagesize_version;	// page 格式版本号
	TransactionId pd_prune_xid; /* oldest prunable XID, or zero if none */
	ItemIdData	pd_linp[FLEXIBLE_ARRAY_MEMBER]; // 数据指针数组
} PageHeaderData;
```

