
## Buffer Manager的结构分析

当一个进程访问

下面是BufferTag的定义：

```c
typedef unsigned int Oid;
typedef uint32 BlockNumber;

typedef enum ForkNumber
{
        InvalidForkNumber = -1,
        MAIN_FORKNUM = 0,
        FSM_FORKNUM,
        VISIBILITYMAP_FORKNUM,
        INIT_FORKNUM
} ForkNumber;

typedef struct RelFileNode
{
        Oid                     spcNode;                /* tablespace */
        Oid                     dbNode;                 /* database */
        Oid                     relNode;                /* relation */
} RelFileNode;

typedef struct buftag
{
        RelFileNode rnode;                      /* physical relation identifier */
        ForkNumber      forkNum;
        BlockNumber blockNum;           /* blknum relative to begin of reln */
} BufferTag;

```
我们可以看到，BufferTag里面包含五个整数，形式是((a,b,c),x,y)。我们称之为五元组。其中(a,b,c)是一个三元组，表示rnode，就是一个表示这个Block在磁盘上哪个表空间上的哪个数据库里面的哪个数据文件。根据rnode三元组，我们可以定位到一个表在磁盘上的数据文件。再提供一个blockNum，我们称之为“块号”，就可以定位这个Block在这个文件中的具体位置。我们知道，假设一个表的文件叫做3764，那么还存在3764_fsm和3764_vm两种类型的辅助文件。这个就叫做fork类型，共Main, FSM和VM三种类型。forkNum就是用来区分fork类型的。有了这个五元组，我们就可以在磁盘上定位任何一个表的一个Block。

```
typedef struct BufferDesc
{
        BufferTag       tag;                    /* ID of page contained in buffer */
        int                     buf_id;                 /* buffer's index number (from 0) */

        /* state of the tag, containing flags, refcount and usagecount */
        pg_atomic_uint32 state;

        int                     wait_backend_pgprocno;  /* backend of pin-count waiter */
        int                     freeNext;               /* link in freelist chain */
        LWLock          content_lock;   /* to lock access to buffer contents */
} BufferDesc;
```
BufferDesc结构把BufferTag和Buffer ID做了映射。Buffer ID是Buffer Pool数组的下标，从0到NBuffers - 1。

```
#define BUFFERDESC_PAD_TO_SIZE  (SIZEOF_VOID_P == 8 ? 64 : 1)

typedef union BufferDescPadded
{
        BufferDesc      bufferdesc;
        char            pad[BUFFERDESC_PAD_TO_SIZE];
} BufferDescPadded;
```
