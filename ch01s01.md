## PostgreSQL的体系架构概览

在完成了第一节PostgreSQL的源码编译安装，数据库的启停，初步使用体验之后，我们要对PostgreSQL的体系结构做一个整体的概述，使得读者心中有一副完整的地图，方便后面的深入学习。简而言之，任何数据库都离不开三大件：文件，内存和进程。PostgreSQL也不例外。这里面有三个概念，文件和内存，读者都应该比较熟悉，进程的概念可能有些读者就不大清楚了。下面我们会对这几个概念进行一些剖析。

PostgreSQL的整体结构，可以用下图来表示：

![](d0015.svg)

当我们执行例如"pg_ctl start"的命令启动PostgreSQL的时候，运行的程序是$PGHOME/bin/postgres这个可执行文件。它运行起来的进程叫做postmaster，是第一个进程，也称为“主进程”。postmaster会首先完成一些初始化的工作，最重要的步骤之一就是创建一块大的共享内存。紧接着postgres会通过fork()这个系统调用创建一系列的子进程。这些子进程被称为“后台”进程(backend process)。在完成各种工作之后，postmaster会监听某一个端口(缺省是5432)。当某一个客户端程序打算连接到PostgreSQL进行数据的增删改查操作的时候，它首先用PostgreSQL服务器的IP地址和监听端口号和postmaster进程建立一个TCP连接。如果这个客户有正确的口令，postmaster就会再通过fork()系统调用创建一个服务进程(server process)，这个服务进程将一对一和客户端的进程建立TCP连接，并为其服务。下面我们结合上图依次来介绍PostgreSQL的进程，内存和文件。

### PostgreSQL的后台进程

#### 进程和线程
我们知道，我们可以使用各种语言编写软件，如C，Java, Go, Rust, Python等等。用C/Java等编译型语言编写好的源程序，被编译器编译成可执行文件，这个文件叫做“程序”。程序是一个躺在磁盘上的文件，如果它不被运行，就没有多大用处。只有用户运行它后，它才能够为我们提供应有的服务。被运行起来的程序被称为“进程”(process)。譬如我们运行的每一个putty窗口，就是一个进程。它可以在Windows下面的Task Manager里面被查看到。操作系统会为进程分配很多资源，包括该进程独享的内存空间。为了进一步提高执行效率，人类又发明了“线程”(thread)的概念。简而言之，线程就是在进程内部多个可以并发执行的单元。线程的执行效率高，但是一个进程内部的多个线程共享本进程的内存，可能会产生冲突，这导致多线程程序编写起来比较困难。如果控制不好，采用线程技术会导致最终的软件稳定性可能会存在一些问题。数据库软件是非常重要的基础性软件，它需要经年累月地不间断运行，所以人类对它的稳定性有极高的要求。为了提高软件的稳定性，PostgreSQL只采用多进程的体系架构，拒绝使用线程。这导致了PostgreSQL的性能并不是最领先的，但是它的稳定性是所有用户都交口称赞的，正如本山大叔对你的挤眉弄眼：“不要看广告，要看疗效。谁用谁知道！” 作为一枚苦逼的数据库运维人员，我深深地知道稳定性意味着什么：没有人想半夜三更被老板的电话叫醒。

#### PostgreSQL的后台进程

从上图中我们可以看出，主进程postmaster通过fork()，创建了多个子进程，如backgroud writer, checkpointer, walwriter等等，就是在右边的那些椭圆形。本书的示例图中一般用椭圆形表示进程，矩形表示内存。这些后台进程的功能我们在后面会逐步介绍。

当PostgreSQL运行起来后，我们可以通过ps命令查看它的后台进程:
```
/* 所有的pg进程都以postgre开头，所以可以用grep postgres进行过滤 */
$ ps -ef | grep postgres | grep -v grep 
postgres     817       1  0 22:32 ?        00:00:00 /opt/software/pg152/bin/postgres
postgres     818     817  0 22:32 ?        00:00:00 postgres: checkpointer
postgres     819     817  0 22:32 ?        00:00:00 postgres: background writer
postgres     821     817  0 22:32 ?        00:00:00 postgres: walwriter
postgres     822     817  0 22:32 ?        00:00:00 postgres: autovacuum launcher
postgres     823     817  0 22:32 ?        00:00:00 postgres: logical replication launcher
```
在上述出现的进程中，我们注意一下817号进程/opt/software/pg152/bin/postgres。这个就是postmaster主进程。如果你的Linux环境支持pstree命令，你可以执行如下命令：
```
$ pstree -p 817
postgres(817)─┬─postgres(818)
              ├─postgres(819)
              ├─postgres(821)
              ├─postgres(822)
              └─postgres(823)
```
这个命令显示出进程818,819,821,822和823的父进程是817。这清晰地展示了它们之间的父子兄弟关系。然后我们执行psql进行本地连接，再查看进程信息：
```
$ psql
psql (15.2)
Type "help" for help.

postgres=# \! ps -ef | grep postgres | grep -v grep
postgres     817       1  0 22:32 ?        00:00:00 /opt/software/pg152/bin/postgres
postgres     818     817  0 22:32 ?        00:00:00 postgres: checkpointer
postgres     819     817  0 22:32 ?        00:00:00 postgres: background writer
postgres     821     817  0 22:32 ?        00:00:00 postgres: walwriter
postgres     822     817  0 22:32 ?        00:00:00 postgres: autovacuum launcher
postgres     823     817  0 22:32 ?        00:00:00 postgres: logical replication launcher
postgres     870     710  0 23:06 pts/0    00:00:00 psql
postgres     871     817  0 23:06 ?        00:00:00 postgres: postgres postgres [local] idle
```


### PostgreSQL的内存结构

下面我们依次来介绍进程，内存和磁盘文件。

### 数据库集群(Database Cluster)

下面我们依次来介绍进程，内存和磁盘文件。

